<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Battle Balls — Instant Render w/ Audio</title>
<style>
  :root { --bg1:#0f1020; --bg2:#1a1d36; --good:#45ff9a; --good2:#8affff; --pink:#ff9fd3; --pink2:#ff7ad9; }
  html,body{height:100%;margin:0;background:radial-gradient(1200px 700px at 20% 10%, #222a, transparent), linear-gradient(160deg,var(--bg1),var(--bg2)); color:#eef; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;}
  .wrap{max-width:980px; margin:16px auto; padding:0 12px;}
  h1{font-weight:800; letter-spacing:.3px; margin:0 0 10px; font-size: clamp(18px, 2.6vw, 28px);}
  .controls{display:grid; grid-template-columns:repeat(12,1fr); gap:10px; align-items:center; margin:10px 0 12px;
    background:#ffffff0f; border:1px solid #ffffff18; padding:10px; border-radius:14px; box-shadow: 0 10px 30px #0006 inset, 0 6px 18px #0004;}
  .controls > *{min-width:0}
  .file,.field{grid-column: span 3; display:flex; align-items:center; gap:8px; padding:6px 8px; background:#ffffff08; border:1px dashed #ffffff22; border-radius:10px; font-size:14px;}
  .field input[type="text"]{flex:1; padding:8px 10px; border-radius:8px; border:1px solid #ffffff2a; background:#ffffff10; color:#eef;}
  input[type="file"]{color:#cfe; max-width:180px}
  .wide{grid-column: span 6;}
  .btnrow{grid-column: span 12; display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  button{padding:10px 14px; border-radius:12px; border:1px solid #ffffff2a; background:linear-gradient(#ffffff24,#ffffff10);
    color:#eef; font-weight:700; letter-spacing:.2px; cursor:pointer; transition:.15s transform,.15s filter; font-size:14px;}
  button:hover{filter:brightness(1.08)} button:active{transform:translateY(1px)}
  small{opacity:.8}
  .progress{margin-top:10px; display:none; align-items:center; gap:10px}
  .bar{height:10px; background:#0006; border:1px solid #ffffff22; border-radius:999px; width:320px; overflow:hidden}
  .fill{height:100%; width:0%; background:linear-gradient(90deg,var(--good),var(--good2))}
  #exportCanvas{ position:fixed; left:-99999px; top:-99999px; width:1px; height:1px; opacity:0; pointer-events:none; }
</style>
</head>
<body>
<div class="wrap">
  <h1>Battle Balls — Instant Vertical Video (WebM + Audio)</h1>
  <div class="controls">
    <span class="file">Ball A Image <input id="imgA" type="file" accept="image/*"></span>
    <span class="file">Ball B Image <input id="imgB" type="file" accept="image/*"></span>
    <span class="field"><span>Title</span><input id="titleInput" type="text" placeholder="Video title (e.g., Battle Balls — E01)"></span>
    <span class="field"><span>Name A</span><input id="nameA" type="text" placeholder="e.g., Draco"></span>
    <span class="field"><span>Name B</span><input id="nameB" type="text" placeholder="e.g., Nimbus"></span>
    <span class="field"><span>FPS</span><input id="fpsInput" type="number" min="20" max="60" step="1" value="30" style="width:90px"></span>
    <span class="field"><span>Mux Speed</span><input id="muxRate" type="number" min="1" max="8" step="1" value="4" style="width:90px"></span>
    <div class="btnrow">
      <button id="renderBtn">Render Video (with audio)</button>
      <small>Tip: Higher <b>Mux Speed</b> = faster finish. If your machine struggles, try 2–3×.</small>
    </div>
  </div>

  <!-- Offscreen canvases -->
  <canvas id="gameCanvas" width="720" height="1280"></canvas>
  <canvas id="exportCanvas" width="1080" height="1920"></canvas>

  <div class="progress" id="progressRow">
    <div class="bar"><div class="fill" id="progFill"></div></div>
    <div id="progText">0%</div>
  </div>
</div>

<script>
/* ===== Whammy-like tiny WebM builder (VP8 frames from image/webp) ===== */
const Whammy = (function(){
  function numToBuffer(num){ const parts=[]; while(num>0){ parts.push(num & 0xff); num>>=8; } return new Uint8Array(parts.reverse()); }
  function strToBuffer(str){ const arr=new Uint8Array(str.length); for(let i=0;i<str.length;i++) arr[i]=str.charCodeAt(i); return arr; }
  function concatBuffers(arr){ let len=0; for(const a of arr) len+=a.length; const out=new Uint8Array(len); let off=0; for(const a of arr){ out.set(a,off); off+=a.length; } return out; }
  function parseRIFF(str){
    let o=0; const R=s=>{const v=str.substr(o,s); o+=s; return v}, U=()=>{const v=str.charCodeAt(o)+(str.charCodeAt(o+1)<<8)+(str.charCodeAt(o+2)<<16)+(str.charCodeAt(o+3)<<24); o+=4; return v; };
    if(R(4)!=="RIFF") throw "Invalid WebP"; U(); if(R(4)!=="WEBP") throw "Invalid WEBP";
    const chunks={}; while(o<str.length){ const f=R(4), sz=U(); chunks[f]=R(sz); } return chunks;
  }
  function parseWebP(riff){ const vp8=riff["VP8 "]; if(!vp8) throw "Not VP8"; return vp8.substr(10); }
  function makeSimpleBlock(track, tc, flags, data){
    const tcA=new Int16Array([tc]); const tcB=new Uint8Array(tcA.buffer);
    return concatBuffers([ new Uint8Array([0xA3]), numToBuffer(1+2+1+data.length), new Uint8Array([(track&0x7f)|0x80]), new Uint8Array([tcB[1],tcB[0]]), new Uint8Array([flags]), data ]);
  }
  function fromImageArray(frames, fps){
    const EBML=[{id:0x1a45dfa3,data:[{id:0x4286,data:1},{id:0x42f7,data:1},{id:0x42f2,data:4},{id:0x42f3,data:8},{id:0x4282,data:"webm"},{id:0x4287,data:2},{id:0x4285,data:2}]},
      {id:0x18538067,data:[{id:0x1549a966,data:[{id:0x2ad7b1,data:numToBuffer(1e6)},{id:0x4d80,data:"whammy"},{id:0x7ba9,data:"whammy"},{id:0x4489,data:numToBuffer(Math.round(frames[frames.length-1].time*1e6))}]},
        {id:0x1654ae6b,data:[{id:0xae,data:[{id:0xd7,data:1},{id:0x73c5,data:1},{id:0x9c,data:0},{id:0x22b59c,data:"und"},{id:0x86,data:"V_VP8"},{id:0x258688,data:"webm"},{id:0x83,data:1},{id:0xe0,data:[{id:0xb0,data:frames[0].w},{id:0xba,data:frames[0].h}]}]}]},
        {id:0x1f43b675,data:[] }]}];
    let clusterTime=0; EBML[1].data[2].data.push({id:0xe7,data:numToBuffer(clusterTime)});
    for(const f of frames){
      const riff=parseRIFF(f.data), vp8= strToBuffer(parseWebP(riff));
      const block=makeSimpleBlock(1, Math.round(f.time*1000 - clusterTime), 0x80, vp8);
      EBML[1].data[2].data.push({id:0xa3,data:block.subarray(1)});
    }
    function idToBuf(id){ const parts=[]; while(id>0){ parts.push(id&0xff); id>>=8; } return new Uint8Array(parts.reverse()); }
    function gen(json){ const out=[]; for(const node of json){ let data=node.data; if(Array.isArray(data)) data=gen(data); if(typeof data==="string") data=strToBuffer(data); if(typeof data==="number") data=numToBuffer(data);
      let size=data.length, bytes=1; for(;bytes<=8;bytes++){ if(size < (1<<(7*bytes))-1) break; } size += (1<<(7*bytes)) -1;
      const sizeBytes=new Uint8Array(bytes); for(let o=bytes-1;o>=0;o--){ sizeBytes[o]=size & 0xff; size>>=8; }
      out.push(idToBuf(node.id)); out.push(sizeBytes); out.push(data);
    } return concatBuffers(out); }
    return new Blob([gen(EBML)],{type:'video/webm'});
  }
  return { fromImageArray };
})();

/* ===== Instant fight sim + audio + fast mux ===== */
(() => {
  // ---------- Tunables ----------
  const EXPORT_W = 1080, EXPORT_H = 1920;  // 9:16
  const TITLE_H = 120, MARGIN = 18;
  const MAX_HP = 5, R_MAX = 44, R_MIN = 22;
  const BASE_SPEED = 6.3, SPEED_EXP = 1.85, SPEED_CAP_BASE = 13.5;
  const KNOCKBACK = 1.35, KNOCKBACK_SAW = 1.85, COLLISION_COOLDOWN = 140;
  const ITEM_SIZE = 28;

  // DOM
  const gameCanvas = document.getElementById('gameCanvas'), g = gameCanvas.getContext('2d');
  const exportCanvas = document.getElementById('exportCanvas'), ex = exportCanvas.getContext('2d');
  const imgAInput = document.getElementById('imgA'), imgBInput = document.getElementById('imgB');
  const titleInput = document.getElementById('titleInput');
  const nameAInput = document.getElementById('nameA'), nameBInput = document.getElementById('nameB');
  const fpsInput = document.getElementById('fpsInput'), muxRateInput = document.getElementById('muxRate');
  const renderBtn = document.getElementById('renderBtn');
  const progRow = document.getElementById('progressRow'), progFill = document.getElementById('progFill'), progText = document.getElementById('progText');

  // Assets
  const imgA = new Image(), imgB = new Image();
  let imgALoaded=false, imgBLoaded=false;
  imgAInput.addEventListener('change', e=>{ const f=e.target.files?.[0]; if(!f) return; imgA.src=URL.createObjectURL(f); imgA.onload=()=>imgALoaded=true; });
  imgBInput.addEventListener('change', e=>{ const f=e.target.files?.[0]; if(!f) return; imgB.src=URL.createObjectURL(f); imgB.onload=()=>imgBLoaded=true; });

  // Helpers
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const rand=(a,b)=>Math.random()*(b-a)+a;
  const radiusForHP=hp=>{ hp=clamp(hp,1,MAX_HP); return R_MIN + (R_MAX-R_MIN)*(hp-1)/(MAX_HP-1); };
  const targetSpeedFor=b=> BASE_SPEED*Math.pow(R_MAX / radiusForHP(b.hp), SPEED_EXP);
  const speedCapFor=b=> SPEED_CAP_BASE*Math.pow(R_MAX / radiusForHP(b.hp), SPEED_EXP);
  function rescaleSpeedToTarget(b){ const t=targetSpeedFor(b), s=Math.hypot(b.vx,b.vy); if(s<1e-6){ const a=Math.random()*Math.PI*2; b.vx=Math.cos(a)*t; b.vy=Math.sin(a)*t; } else { const k=t/s; b.vx*=k; b.vy*=k; } }
  function clampVel(b){ const cap=speedCapFor(b), s=Math.hypot(b.vx,b.vy); if(s>cap){ const k=cap/(s||1e-6); b.vx*=k; b.vy*=k; } }
  const circleCollision=(a,b)=>Math.hypot(b.x-a.x,b.y-a.y) < radiusForHP(a.hp)+radiusForHP(b.hp);
  function resolveElastic(a,b,f=1){
    const r1=radiusForHP(a.hp), r2=radiusForHP(b.hp);
    const dx=b.x-a.x, dy=b.y-a.y, dist=Math.hypot(dx,dy)||1e-6;
    const nx=dx/dist, ny=dy/dist, tx=-ny, ty=nx;
    const v1n=a.vx*nx + a.vy*ny, v1t=a.vx*tx + a.vy*ty, v2n=b.vx*nx + b.vy*ny, v2t=b.vx*tx + b.vy*ty;
    const v1nAfter = v2n*f, v2nAfter = v1n*f;
    a.vx=v1t*tx + v1nAfter*nx; a.vy=v1t*ty + v1nAfter*ny;
    b.vx=v2t*tx + v2nAfter*nx; b.vy=v2t*ty + v2nAfter*ny;
    const overlap=(r1+r2-dist), sep=overlap/2+0.2; a.x-=nx*sep; a.y-=ny*sep; b.x+=nx*sep; b.y+=ny*sep;
    clampVel(a); clampVel(b);
  }

  // Pretty arena
  function drawGrid(){
    g.save(); g.globalAlpha=0.12; const W=gameCanvas.width, H=gameCanvas.height;
    const step=Math.max(32,Math.min(48,Math.floor(Math.min(W,H)/12)));
    g.strokeStyle='#ffffff22'; g.lineWidth=1;
    for(let x=step;x<W;x+=step){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,H); g.stroke(); }
    for(let y=step;y<H;y+=step){ g.beginPath(); g.moveTo(0,y); g.lineTo(W,y); g.stroke(); }
    g.globalAlpha=1; const grd=g.createLinearGradient(0,0,0,H); grd.addColorStop(0,'#ffffff18'); grd.addColorStop(1,'#ffffff06'); g.strokeStyle=grd; g.lineWidth=2; g.strokeRect(1,1,W-2,H-2); g.restore();
  }
  function drawItem(x,y,type){
    g.save(); g.translate(x,y);
    if(type==='saw'){
      g.fillStyle='#ddd'; g.strokeStyle='#0009'; g.lineWidth=2;
      g.beginPath(); g.arc(0,0, ITEM_SIZE*0.6, 0, Math.PI*2); g.fill(); g.stroke();
      for (let i=0;i<12;i++){ const a=i*(Math.PI*2/12), r1=ITEM_SIZE*0.6, r2=ITEM_SIZE*0.9; g.beginPath(); g.moveTo(Math.cos(a)*r1,Math.sin(a)*r1); g.lineTo(Math.cos(a)*r2,Math.sin(a)*r2); g.stroke(); }
      g.fillStyle='#999'; g.beginPath(); g.arc(0,0, 5, 0, Math.PI*2); g.fill();
      g.shadowBlur = 14; g.shadowColor = '#ffd16666'; g.beginPath(); g.arc(0,0, ITEM_SIZE*0.9, 0, Math.PI*2); g.strokeStyle='#ffd16644'; g.stroke();
    } else {
      g.fillStyle = '#ff6fae'; g.strokeStyle = '#0008'; g.lineWidth = 2;
      const s = ITEM_SIZE*0.05;
      g.beginPath();
      g.moveTo(0, 6*s);
      g.bezierCurveTo(0, 6*s, -6*s, 0, -6*s, -4*s);
      g.bezierCurveTo(-6*s, -8*s, -2*s, -8*s, 0, -4*s);
      g.bezierCurveTo(2*s, -8*s, 6*s, -8*s, 6*s, -4*s);
      g.bezierCurveTo(6*s, 0, 0, 6*s, 0, 6*s);
      g.fill(); g.stroke(); g.shadowBlur = 12; g.shadowColor = '#ff6fae66'; g.fill();
    }
    g.restore();
  }
  function drawBall(b){
    if (b.removed) return;
    const r = radiusForHP(b.hp);
    g.save(); g.shadowBlur=b.sharp?22:14; g.shadowColor=b.sharp?'#ffd166':'#000';
    g.beginPath(); g.arc(b.x,b.y,r+(b.sharp?1.5:0),0,Math.PI*2); g.fillStyle='#000'; g.fill(); g.restore();
    g.save(); g.beginPath(); g.arc(b.x,b.y,r,0,Math.PI*2); g.closePath(); g.clip();
    if(b.img && b.imgLoaded()){ const iw=b.img.width, ih=b.img.height, sc=Math.max((2*r)/iw,(2*r)/ih); g.drawImage(b.img, b.x-iw*sc/2, b.y-ih*sc/2, iw*sc, ih*sc); }
    else { const gr=g.createLinearGradient(b.x-r,b.y-r,b.x+r,b.y+r); gr.addColorStop(0,'#ffffff22'); gr.addColorStop(1,b.color+'55'); g.fillStyle=gr; g.fillRect(b.x-r,b.y-r,r*2,r*2); }
    g.restore();
    g.beginPath(); g.arc(b.x,b.y,r,0,Math.PI*2); g.strokeStyle=b.sharp?'#ffd166':'#ffffff33'; g.lineWidth=b.sharp?3:2; g.stroke();
  }

  // Funky title
  function drawFunkyTitle(yCenter){
    const text=(titleInput.value||'Battle Balls').slice(0,120);
    const base=64;
    const grad = ex.createLinearGradient(0, yCenter-40, EXPORT_W, yCenter+40);
    grad.addColorStop(0, '#ffec78'); grad.addColorStop(0.5, '#ffa7ef'); grad.addColorStop(1, '#8af7ff');
    ex.textAlign='center'; ex.textBaseline='middle';
    const chars=[...text]; const startX = EXPORT_W/2 - (chars.length * base * 0.28); let x=startX; const t=performance.now();
    for(let i=0;i<chars.length;i++){
      const wob=Math.sin((t*0.004)+(i*0.6))*6, rot=Math.sin((t*0.002)+(i*0.8))*0.08;
      ex.save(); ex.translate(x, yCenter+wob); ex.rotate(rot);
      ex.font=`900 ${base}px "Marker Felt","Chalkduster","Comic Sans MS","Segoe Print",system-ui,sans-serif`;
      ex.fillStyle=grad; ex.shadowColor='#000'; ex.shadowBlur=14; ex.fillText(chars[i],0,0); ex.restore(); x += base*0.56;
    }
  }

  // Bars row (side-by-side) using typed names
  function drawBarsRow(y, nameA, nameB, fracA, fracB, sawA, sawB){
    const pad=MARGIN, gap=22, cellW=(EXPORT_W-pad*2-gap)/2, barH=30, radius=12;
    function rr(ctx,x,y,w,h,r,f,s){ if(w<2*r)r=w/2; if(h<2*r)r=h/2; ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); if(f)ctx.fill(); if(s)ctx.stroke(); }
    function cell(x,label,frac,c1,c2,saw){
      ex.font='700 22px system-ui,sans-serif'; ex.textAlign='left'; ex.textBaseline='alphabetic'; ex.fillStyle='#e8f6ff';
      ex.fillText(label, x, y-6);
      const tx=x, ty=y+4, tw=cellW, th=barH;
      ex.fillStyle='#00000066'; rr(ex,tx,ty,tw,th,radius,true,false);
      const w=Math.max(0,Math.min(tw,tw*frac)), grad=ex.createLinearGradient(tx,ty,tx+tw,ty);
      grad.addColorStop(0,c1); grad.addColorStop(1,c2); ex.fillStyle=grad; rr(ex,tx,ty,w,th,radius,true,false);
      if(saw){ const bx=tx+tw-64, by=ty-18, bw=60, bh=th+18; ex.fillStyle='#ffd166'; ex.strokeStyle='#0006'; ex.lineWidth=2; rr(ex,bx,by,bw,bh,10,true,true); ex.fillStyle='#111'; ex.font='bold 18px system-ui,sans-serif'; ex.textAlign='center'; ex.textBaseline='middle'; ex.fillText('SAW', bx+bw/2, ty+th/2); }
    }
    cell(pad, nameA, fracA, '#45ff9a', '#8affff', sawA);
    cell(pad+cellW+gap, nameB, fracB, '#ff9fd3', '#ff7ad9', sawB);
  }

  // Shockwave + particles for obliteration
  const fx = { particles:[], shockwaves:[], screenFlash:0 };
  function spawnObliteration(x,y,colorA,colorB){
    fx.screenFlash = 0.35; // seconds
    fx.shockwaves.push({x,y,r:6,dr:22,life:0.7,age:0});
    for(let i=0;i<220;i++){
      const ang=Math.random()*Math.PI*2, spd=rand(90,420);
      fx.particles.push({x,y, vx:Math.cos(ang)*spd, vy:Math.sin(ang)*spd, life:rand(0.5,1.1), age:0, size:rand(1.5,3.5), color:(i%2===0)?colorA:colorB});
    }
  }
  function updateFX(dt){ for(let p of fx.particles){ p.age+=dt; p.x+=p.vx*dt; p.y+=p.vy*dt; p.vy+=40*dt; } for(let i=fx.particles.length-1;i>=0;i--){ if(fx.particles[i].age>fx.particles[i].life) fx.particles.splice(i,1); }
    for(let s of fx.shockwaves){ s.age+=dt; s.r += s.dr*dt*60; } for(let i=fx.shockwaves.length-1;i>=0;i--){ if(fx.shockwaves[i].age>s.life) fx.shockwaves.splice(i,1); }
    if(fx.screenFlash>0) fx.screenFlash -= dt;
  }
  function drawParticles(){ for(let p of fx.particles){ const a=Math.max(0,1-p.age/p.life); g.globalAlpha=a; g.fillStyle=p.color; g.beginPath(); g.arc(p.x,p.y,p.size,0,Math.PI*2); g.fill(); g.globalAlpha=1; } }

  // Audio event timeline
  const audioEvents = []; // {t,type} where type in ['saw','heart','hit','boom']

  // Fight state
  const state = {
    W: gameCanvas.width, H: gameCanvas.height, t:0,
    balls: [
      { name:'A', x:0, y:0, vx:0, vy:0, hp:MAX_HP, sharp:false, img:imgA, imgLoaded:()=>imgALoaded, color:'#9ef0ff', removed:false },
      { name:'B', x:0, y:0, vx:0, vy:0, hp:MAX_HP, sharp:false, img:imgB, imgLoaded:()=>imgBLoaded, color:'#ff7ad9', removed:false }
    ],
    items: { saw:null, heart:null },
    lastHitTime: -9999,
    winner: null,
  };
  function setSpeedToTarget(b, dx=1, dy=0){ const t=targetSpeedFor(b), L=Math.hypot(dx,dy)||1; b.vx=(dx/L)*t; b.vy=(dy/L)*t; }
  function resetFight(nameA, nameB){
    state.t=0;
    state.balls[0].name=nameA||'Ball A';
    state.balls[1].name=nameB||'Ball B';
    for(const b of state.balls){ b.hp=MAX_HP; b.removed=false; b.sharp=false; }
    state.balls[0].x=state.W*0.3; state.balls[0].y=state.H*0.35; setSpeedToTarget(state.balls[0], +1, -0.6);
    state.balls[1].x=state.W*0.7; state.balls[1].y=state.H*0.65; setSpeedToTarget(state.balls[1], -0.95, +0.85);
    state.items.saw={ x:rand(60,state.W-60), y:rand(60,state.H-60) };
    state.items.heart=null;
    state.winner=null;
    fx.particles.length=0; fx.shockwaves.length=0; fx.screenFlash=0;
    audioEvents.length=0;
  }

  function stepPhysics(dt){
    const {W,H,balls,items} = state;
    state.t += dt;

    // move
    for(const b of balls){
      if(b.removed) continue;
      const r=radiusForHP(b.hp);
      b.x+=b.vx*dt*60; b.y+=b.vy*dt*60;
      if(b.x<r){ b.x=r; b.vx=Math.abs(b.vx); }
      if(b.x>W-r){ b.x=W-r; b.vx=-Math.abs(b.vx); }
      if(b.y<r){ b.y=r; b.vy=Math.abs(b.vy); }
      if(b.y>H-r){ b.y=H-r; b.vy=-Math.abs(b.vy); }
      clampVel(b);
    }

    // items
    for(const b of balls){
      if(b.removed) continue;
      const r=radiusForHP(b.hp);
      if(items.saw && Math.hypot(b.x-items.saw.x,b.y-items.saw.y) < r + ITEM_SIZE*0.6){
        balls[0].sharp=false; balls[1].sharp=false; b.sharp=true; items.saw=null;
        audioEvents.push({t:state.t, type:'saw'});
      }
      if(items.heart && Math.hypot(b.x-items.heart.x,b.y-items.heart.y) < r + ITEM_SIZE*0.4){
        if(b.hp<MAX_HP){ b.hp++; rescaleSpeedToTarget(b); audioEvents.push({t:state.t, type:'heart'}); }
        items.heart=null;
      }
    }
    if(!items.heart && Math.random()<0.01){ items.heart = { x: rand(60,W-60), y: rand(60,H-60) }; }

    // collisions
    if(circleCollision(balls[0],balls[1])){
      const now=state.t*1000;
      let kb = KNOCKBACK;
      if(now - state.lastHitTime > COLLISION_COOLDOWN){
        const a=balls[0], b=balls[1];
        if(!a.removed && !b.removed){
          if(a.sharp && !b.sharp){ b.hp=Math.max(0,b.hp-1); a.sharp=false; rescaleSpeedToTarget(b); rescaleSpeedToTarget(a); audioEvents.push({t:state.t, type:'hit'}); kb=KNOCKBACK_SAW; }
          else if(b.sharp && !a.sharp){ a.hp=Math.max(0,a.hp-1); b.sharp=false; rescaleSpeedToTarget(a); rescaleSpeedToTarget(b); audioEvents.push({t:state.t, type:'hit'}); kb=KNOCKBACK_SAW; }
        }
        state.lastHitTime = now;
      }
      resolveElastic(balls[0],balls[1],kb);
    }

    // winner + obliteration
    if(!state.winner && ((balls[0].hp<=0 && !balls[0].removed) || (balls[1].hp<=0 && !balls[1].removed))){
      const loser = (balls[0].hp<=0 && !balls[0].removed) ? balls[0] : balls[1];
      const win = loser===balls[0] ? balls[1] : balls[0];
      state.winner = win.name;
      spawnObliteration(loser.x, loser.y, '#ffffff', win===balls[0] ? '#9ef0ff' : '#ff7ad9');
      audioEvents.push({t:state.t, type:'boom'});
      loser.removed = true;
    }

    updateFX(dt);
  }

  // Compose export frame (title + side-by-side bars + big arena + winner caption when done)
  function composeExportFrame(nameA, nameB){
    // BG
    ex.clearRect(0,0,EXPORT_W,EXPORT_H);
    const bg=ex.createLinearGradient(0,0,0,EXPORT_H); bg.addColorStop(0,'#0f1020'); bg.addColorStop(1,'#1a1d36'); ex.fillStyle=bg; ex.fillRect(0,0,EXPORT_W,EXPORT_H);
    if (fx.screenFlash>0){ const a=Math.min(0.75, fx.screenFlash*1.8); ex.fillStyle=`rgba(255,255,255,${a})`; ex.fillRect(0,0,EXPORT_W,EXPORT_H); }

    // title
    drawFunkyTitle(TITLE_H/2);
    ex.strokeStyle='#ffffff22'; ex.lineWidth=2; ex.beginPath(); ex.moveTo(MARGIN,TITLE_H); ex.lineTo(EXPORT_W-MARGIN,TITLE_H); ex.stroke();

    // bars row
    const fracA=(state.balls[0].hp||0)/MAX_HP, fracB=(state.balls[1].hp||0)/MAX_HP;
    drawBarsRow(TITLE_H+52, nameA, nameB, fracA, fracB, state.balls[0].sharp && !state.balls[0].removed, state.balls[1].sharp && !state.balls[1].removed);

    // arena
    const availTop = TITLE_H + 52 + 30 + 18;
    const availH = EXPORT_H - availTop - MARGIN;
    const availW = EXPORT_W - MARGIN*2;
    const srcW=gameCanvas.width, srcH=gameCanvas.height, srcAspect=srcW/srcH, dstAspect=availW/availH;
    let dw=availW, dh=availH; if(srcAspect>dstAspect) dh=dw/srcAspect; else dw=dh*srcAspect;
    const dx=(EXPORT_W-dw)/2, dy=availTop + (availH-dh)/2;
    ex.drawImage(gameCanvas, 0,0,srcW,srcH, dx, dy, dw, dh);

    // shockwaves on export
    for(let s of fx.shockwaves){
      const t = Math.max(0,1 - s.age/s.life);
      ex.strokeStyle = `rgba(255,255,255,${0.35*t})`;
      ex.lineWidth = 6*t;
      ex.beginPath();
      ex.arc(dx + (s.x / srcW)*dw, dy + (s.y / srcH)*dh, s.r * (dw/srcW), 0, Math.PI*2);
      ex.stroke();
    }

    // Winner caption (if decided)
    if(state.winner){
      const winnerName = state.winner;
      ex.save();
      ex.font = '900 60px system-ui, sans-serif';
      ex.textAlign='center'; ex.textBaseline='middle';
      ex.shadowColor='#000'; ex.shadowBlur=24; ex.fillStyle='#ffffff';
      ex.fillText(`${winnerName} WINS!`, EXPORT_W/2, dy + dh*0.12);
      ex.restore();
    }
  }

  // Draw one game frame
  function drawGameFrame(){
    g.clearRect(0,0,gameCanvas.width,gameCanvas.height);
    drawGrid();
    const it=state.items;
    if(it.heart) drawItem(it.heart.x, it.heart.y, 'heart');
    if(it.saw)   drawItem(it.saw.x,   it.saw.y,   'saw');
    drawBall(state.balls[0]); drawBall(state.balls[1]);
    drawParticles();
  }

  // Offline audio render from events
  async function renderAudioBuffer(durationSec){
    const sr=48000;
    const actx=new OfflineAudioContext(2, Math.ceil(durationSec*sr), sr);
    // little helper
    const tone = (t0,dur,freq,type='sine',gain=0.07, sweepTo=null) => {
      const o=actx.createOscillator(); o.type=type; o.frequency.value=freq; if(sweepTo) o.frequency.linearRampToValueAtTime(sweepTo, t0+dur);
      const g=actx.createGain(); g.gain.setValueAtTime(gain, t0); g.gain.exponentialRampToValueAtTime(0.0001, t0+dur);
      o.connect(g).connect(actx.destination); o.start(t0); o.stop(t0+dur);
    };
    const noise = (t0,dur,gain=0.15) => {
      const nSamps=Math.floor(sr*dur), buf=actx.createBuffer(1,nSamps,sr), data=buf.getChannelData(0);
      for(let i=0;i<nSamps;i++) data[i]=(Math.random()*2-1)*(1 - i/nSamps);
      const src=actx.createBufferSource(); src.buffer=buf;
      const g=actx.createGain(); g.gain.setValueAtTime(gain, t0); g.gain.linearRampToValueAtTime(0.0, t0+dur);
      src.connect(g).connect(actx.destination); src.start(t0);
    };

    for(const ev of audioEvents){
      const t=clamp(ev.t,0,durationSec-0.01);
      if(ev.type==='saw'){ tone(t,0.08,220,'square',0.06,800); tone(t+0.06,0.11,360,'sawtooth',0.05,1000); }
      if(ev.type==='heart'){ tone(t,0.07,523,'triangle',0.06); tone(t+0.09,0.08,659,'triangle',0.06); tone(t+0.18,0.10,784,'triangle',0.07); }
      if(ev.type==='hit'){ tone(t,0.06,120,'sine',0.09); }
      if(ev.type==='boom'){ tone(t,0.65,320,'sine',0.05,1250); noise(t+0.14,0.32,0.16); }
    }
    return actx.startRendering();
  }

  // Main render with audio and fast mux
  async function renderInstantWithAudio(){
    const FPS = clamp(+fpsInput.value || 30, 20, 60);
    const muxRate = clamp(+muxRateInput.value || 4, 1, 8);
    const nameA = (nameAInput.value||'Ball A').trim() || 'Ball A';
    const nameB = (nameBInput.value||'Ball B').trim() || 'Ball B';

    // Prep
    resetFight(nameA, nameB);
    renderBtn.disabled = true; progRow.style.display='flex'; progFill.style.width='0%'; progText.textContent='Simulating…';

    // Simulate & frame out until winner + short random outro
    const frames = [];
    const dt = 1 / FPS;
    let outroLeft = 0;
    while(true){
      // step sim
      stepPhysics(dt);
      // draw layers
      drawGameFrame();
      composeExportFrame(nameA, nameB);
      // capture frame as WebP (VP8) — quality 0.9
      const durl = exportCanvas.toDataURL('image/webp',0.9);
      const base = durl.split(',')[1];
      frames.push({ data: atob(base), time: frames.length * (1000/FPS) / 1000.0, w: EXPORT_W, h: EXPORT_H });

      // winner logic for organic duration
      if(state.winner){
        if(outroLeft === 0) outroLeft = rand(0.8, 1.6); // seconds
        else {
          outroLeft -= dt;
          if(outroLeft <= 0) break;
        }
      }

      // progress tick
      if (frames.length % Math.max(1, Math.floor(FPS/2)) === 0){
        progText.textContent = `Simulating… ${frames.length}f`;
        await new Promise(r=>setTimeout(r,0)); // yield to UI
      }
      // safety cap (in case no one ever wins; extremely unlikely)
      if (frames.length > FPS*30) break; // max ~30s
    }

    // Encode silent video
    progText.textContent='Encoding video…';
    await new Promise(r=>setTimeout(r,0));
    const silentBlob = Whammy.fromImageArray(frames, FPS);

    // Render audio buffer (duration = sim length)
    const durationSec = frames.length / FPS;
    progText.textContent='Rendering audio…';
    const audioBuffer = await renderAudioBuffer(durationSec);

    // Fast mux: play silent video at N× speed + play audio buffer at same rate, record combined
    progText.textContent='Muxing (fast)…';
    const finalBlob = await fastMux(silentBlob, audioBuffer, muxRate);

    // Download
    const title = (titleInput.value||'Battle Balls').trim().replace(/[^a-z0-9\-]+/gi,'_').slice(0,60) || 'Battle_Balls';
    const url = URL.createObjectURL(finalBlob);
    const a = document.createElement('a');
    a.href = url; a.download = `${title}_${new Date().toISOString().replace(/[:.]/g,'-')}.webm`;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 5000);

    // Done
    progFill.style.width='100%'; progText.textContent='Done';
    setTimeout(()=>{ progRow.style.display='none'; }, 800);
    renderBtn.disabled = false;
  }

  async function fastMux(silentVideoBlob, audioBuffer, rate){
    // Create hidden video
    const video = document.createElement('video');
    video.muted = true; video.playsInline = true; video.src = URL.createObjectURL(silentVideoBlob);
    video.style.position='fixed'; video.style.left='-99999px'; video.style.top='-99999px';
    document.body.appendChild(video);
    await video.play().catch(()=>{}); // prime
    video.pause();
    video.playbackRate = rate;

    // Capture video stream
    const vStream = video.captureStream ? video.captureStream() : video.mozCaptureStream();
    const vTrack = vStream.getVideoTracks()[0];

    // Build live audio from the offline buffer
    const AC = new (window.AudioContext || window.webkitAudioContext)();
    const dest = AC.createMediaStreamDestination();
    const src = AC.createBufferSource();
    src.buffer = audioBuffer;
    src.playbackRate.value = rate;
    src.connect(dest);
    // (Optional) don’t route to speakers to keep it quiet while muxing
    // src.connect(AC.destination); // uncomment if you want to hear it

    const combined = new MediaStream();
    if (vTrack) combined.addTrack(vTrack);
    const aTrack = dest.stream.getAudioTracks()[0]; if (aTrack) combined.addTrack(aTrack);

    // Recorder
    const mime = getBestMime();
    const rec = new MediaRecorder(combined, { mimeType: mime, videoBitsPerSecond: 8_000_000 });
    const chunks=[];
    rec.ondataavailable = e => { if (e.data && e.data.size) chunks.push(e.data); };
    const done = new Promise(res=> rec.onstop = () => res(new Blob(chunks, {type: rec.mimeType || 'video/webm'})));

    // start both
    rec.start();
    const tStart = AC.currentTime + 0.05;
    src.start(tStart);
    await video.play(); // starts immediately at the set playbackRate

    await new Promise(res=> video.onended = res);
    rec.stop();
    src.stop();
    AC.close();
    video.remove();
    return await done;
  }

  function getBestMime(){
    const order = ['video/webm;codecs=vp9,opus','video/webm;codecs=vp8,opus','video/webm'];
    for (const t of order){ if (MediaRecorder.isTypeSupported(t)) return t; }
    return '';
  }

  document.getElementById('renderBtn').addEventListener('click', renderInstantWithAudio);

})();
</script>
</body>
</html>
