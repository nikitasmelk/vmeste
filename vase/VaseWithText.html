<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"
  />
  <title>Biome — Spin + Audio</title>
  <style>
    html, body { height: 100dvh; width: 100vw; }
    body {
      margin: 0; background: #000; overflow: hidden;
      overscroll-behavior: none; touch-action: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;
    }
    canvas { display: block; width: 100vw !important; height: 100dvh !important; }

    .panel {
      position: fixed; top: 12px; left: 12px; z-index: 9999;
      width: min(94vw, 460px);
      max-height: calc(100dvh - 24px);
      overflow: hidden auto;
      border-radius: 14px; backdrop-filter: blur(8px);
      background: #0b1020e0; border: 1px solid #88a7ff2a; color: #eaf0ff;
      box-shadow: 0 8px 28px #000a; font-size: 12px; letter-spacing: .02em;
      display: none;
    }
    .tabs {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      padding: 8px;
      background: #0f1a38a6;
      border-bottom: 1px solid #5c75b42a;
      position: sticky;
      top: 0;
      z-index: 2;
    }
    .tab-btn {
      padding: 8px 10px; border-radius: 10px; border:1px solid #6aa2ff33;
      background:#0e1736; color:#d9e6ff; cursor:pointer; text-align:center;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .tab-btn.active { background:#1a2a62; border-color:#89a6ff66; color:#eaf0ff; }
    .tabpages { padding: 10px; }
    .tabpage { display: none; }
    .tabpage.active { display: block; }
    h3 { margin: 4px 0 10px; font-size: 13px; color:#cfe0ff; }
    .row {
      display: grid;
      grid-template-columns: 1fr 60px;
      gap: 8px;
      align-items: center;
      margin: 6px 0;
    }
    .row input[type="range"] { width: 100%; }
    .row input[type="number"] {
      width: 60px; background:#0d1a3a; color:#eaf0ff; border:1px solid #446;
      border-radius:6px; padding:4px 6px; font-size:12px;
    }
    .hint { opacity:.8; font-size:11px; margin:6px 0 2px; }
    .two { display:flex; gap:8px; margin-top:8px; }
    .two > button {
      flex:1 1 0; padding:8px 10px; border-radius:10px; border:1px solid #6aa2ff33;
      background:#0e1736; color:#d9e6ff; cursor:pointer;
    }
    .inline { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .swatch { display:flex; gap:6px; }
    .swatch input[type="number"] { width:52px; }
    label { cursor: default; }

    #toggleControls {
      position: fixed; right: 16px; bottom: 16px; z-index: 10000;
      padding: 10px 14px; border-radius: 12px; border: 1px solid #6aa2ff33;
      background: #0b1020; color: #cfe0ff; font: 600 12px/1.2 system-ui;
      letter-spacing: .05em; box-shadow: 0 6px 20px #0007;
    }

    #enableMotion {
      position: fixed; inset: auto 16px 66px auto; z-index: 10000;
      padding: 10px 14px; border-radius: 12px; border: 1px solid #6aa2ff33;
      background: #0b1020; color: #cfe0ff; font: 600 12px/1.2 system-ui;
      letter-spacing: .05em; box-shadow: 0 6px 20px #0007; display: none;
    }

    input[type="checkbox"] {
      width: auto;
      accent-color: #7fa3ff;
    }
  </style>
</head>
<body>
  <div class="panel" id="panel">
    <div class="tabs" id="tabs">
      <button class="tab-btn active" data-tab="vaseTab">vase</button>
      <button class="tab-btn" data-tab="roomTab">room size & framing</button>
      <button class="tab-btn" data-tab="wallImgTab">wall image controls</button>
      <button class="tab-btn" data-tab="lightsTab">lights controls</button>
      <button class="tab-btn" data-tab="roomFxTab">room effects</button>
      <button class="tab-btn" data-tab="waterTab">water effects</button>
      <button class="tab-btn" data-tab="globalFxTab">global effects</button>
      <button class="tab-btn" data-tab="vaseFxTab">vase effects</button>
      <button class="tab-btn" data-tab="headerTab">header + badges</button>
    </div>

    <div class="tabpages">
      <!-- Vase -->
      <div class="tabpage active" id="vaseTab">
        <h3>Vase</h3>
        <div class="row"><label>Scale ×</label><input id="vaseNum" type="number" step="0.01"><input id="vase" type="range" min="0.2" max="4.0" step="0.01"></div>
        <div class="row"><label>Tallness (Y)</label><input id="vaseYNum" type="number" step="0.01"><input id="vaseY" type="range" min="0.5" max="3.0" step="0.01"></div>
        <div class="row"><label>Pos Z</label><input id="vaseZNum" type="number" step="0.1"><input id="vaseZ" type="range" min="-40" max="2" step="0.1"></div>
        <div class="row"><label>Pos Y</label><input id="vaseYPosNum" type="number" step="0.1"><input id="vaseYPos" type="range" min="-10" max="8" step="0.1"></div>
        <h3>Spin</h3>
        <div class="row"><label>Damping</label><input id="dampNum" type="number" step="0.001"><input id="damp" type="range" min="0.90" max="0.999" step="0.001"></div>
        <div class="row"><label>Min Spin</label><input id="minNum" type="number" step="0.01"><input id="min" type="range" min="0.0" max="0.6" step="0.01"></div>
        <div class="row"><label>Swipe Impulse</label><input id="impNum" type="number" step="0.0001"><input id="imp" type="range" min="0.0005" max="0.05" step="0.0001"></div>
        <div class="two">
          <button id="printControlsBtn">Print controls</button>
          <button id="copyControlsBtn">Copy controls</button>
        </div>
      </div>

      <!-- Room size & framing -->
      <div class="tabpage" id="roomTab">
        <h3>Room Size (auto-fit)</h3>
        <div class="hint">Depth drives room size; width/height auto-fit to keep the outside invisible.</div>
        <div class="row"><label>Depth</label><input id="dNum" type="number" step="0.1"><input id="d" type="range" min="3" max="40" step="0.1"></div>
        <h3>Framing</h3>
        <div class="row"><label>Room Z</label><input id="zNum" type="number" step="0.1"><input id="z" type="range" min="-40" max="0" step="0.1"></div>
      </div>

      <!-- Wall image controls -->
      <div class="tabpage" id="wallImgTab">
        <h3>Wall Image</h3>
        <div class="row"><label>Image Zoom</label><input id="zoomNum" type="number" step="0.01"><input id="zoom" type="range" min="0.5" max="3.0" step="0.01"></div>
        <div class="row"><label>Border Opacity</label><input id="edgeNum" type="number" step="0.01"><input id="edge" type="range" min="0" max="1" step="0.01"></div>
      </div>

      <!-- Lights controls -->
      <div class="tabpage" id="lightsTab">
        <h3>Lights</h3>
        <div class="row"><label>Exposure</label><input id="expNum" type="number" step="0.01"><input id="exp" type="range" min="0.2" max="3.5" step="0.01"></div>
        <div class="row"><label>Ambient</label><input id="ambNum" type="number" step="0.01"><input id="amb" type="range" min="0" max="3.5" step="0.01"></div>
        <div class="row"><label>Hemisphere</label><input id="hemNum" type="number" step="0.01"><input id="hem" type="range" min="0" max="3.5" step="0.01"></div>
        <div class="row"><label>Rim</label><input id="rimNum" type="number" step="0.01"><input id="rim" type="range" min="0" max="5" step="0.01"></div>
        <div class="row"><label>Key</label><input id="keyNum" type="number" step="0.01"><input id="key" type="range" min="0" max="5" step="0.01"></div>
        <h3>Vase Light</h3>
        <div class="row"><label>Intensity</label><input id="vlINum" type="number" step="0.01"><input id="vlI" type="range" min="0" max="30" step="0.01"></div>
        <div class="row"><label>Distance</label><input id="vlDNum" type="number" step="0.1"><input id="vlD" type="range" min="0.1" max="40" step="0.1"></div>
        <div class="row"><label>Decay</label><input id="vlDecNum" type="number" step="0.1"><input id="vlDec" type="range" min="0" max="3" step="0.1"></div>
        <div class="row"><label>Y Position</label><input id="vlYNum" type="number" step="0.01"><input id="vlY" type="range" min="-4" max="4" step="0.01"></div>
      </div>

      <!-- Room effects -->
      <div class="tabpage" id="roomFxTab">
        <h3>Room Effects</h3>
        <div class="row"><label>Wall Emissive</label><input id="emisNum" type="number" step="0.01"><input id="emis" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>Disp Amp</label><input id="dispNum" type="number" step="0.001"><input id="disp" type="range" min="0" max="0.15" step="0.001"></div>
        <div class="row"><label>Disp Speed</label><input id="dsNum" type="number" step="0.01"><input id="ds" type="range" min="0" max="8" step="0.01"></div>
      </div>

      <!-- Water effects -->
      <div class="tabpage" id="waterTab">
        <h3>Water (visible & fast)</h3>
        <div class="row"><label>Amplitude</label><input id="wAmpNum" type="number" step="0.01"><input id="wAmp" type="range" min="0" max="3.0" step="0.01"></div>
        <div class="row"><label>Frequency</label><input id="wFreqNum" type="number" step="0.1"><input id="wFreq" type="range" min="1" max="60" step="0.1"></div>
        <div class="row"><label>Wave Speed</label><input id="wSpeedNum" type="number" step="0.01"><input id="wSpeed" type="range" min="0" max="8" step="0.01"></div>
        <div class="row"><label>Falloff</label><input id="wFallNum" type="number" step="0.01"><input id="wFall" type="range" min="0.1" max="4.0" step="0.01"></div>
        <div class="row"><label>Alpha</label><input id="wAlphaNum" type="number" step="0.01"><input id="wAlpha" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>Radius</label><input id="wRadNum" type="number" step="0.1"><input id="wRad" type="range" min="0.5" max="8.0" step="0.1"></div>
        <div class="row"><label>Pixelation</label><input id="wPixNum" type="number" step="1"><input id="wPix" type="range" min="1" max="48" step="1"></div>
        <div class="row"><label>Y Offset</label><input id="wYNum" type="number" step="0.01"><input id="wY" type="range" min="-3" max="3" step="0.01"></div>
        <div class="inline">
          <span>Tint (RGB 0..1)</span>
          <div class="swatch">
            <input id="wR" type="number" min="0" max="1" step="0.01">
            <input id="wG" type="number" min="0" max="1" step="0.01">
            <input id="wB" type="number" min="0" max="1" step="0.01">
          </div>
        </div>
      </div>

      <!-- Global effects -->
      <div class="tabpage" id="globalFxTab">
        <h3>Global Effects</h3>
        <div class="row"><label>Pixel Size</label><input id="pixNum" type="number" step="1"><input id="pix" type="range" min="1" max="24" step="1"></div>
        <div class="row"><label>Dither Strength</label><input id="dithNum" type="number" step="0.01"><input id="dith" type="range" min="0" max="1" step="0.01"></div>
      </div>

      <!-- Vase effects -->
      <div class="tabpage" id="vaseFxTab">
        <h3>Glass Material (live)</h3>
        <div class="row"><label>Transmission</label><input id="glassTransNum" type="number" step="0.01"><input id="glassTrans" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>Thickness</label><input id="glassThickNum" type="number" step="0.01"><input id="glassThick" type="range" min="0.1" max="4" step="0.01"></div>
        <div class="row"><label>IOR</label><input id="glassIorNum" type="number" step="0.01"><input id="glassIor" type="range" min="1.0" max="2.5" step="0.01"></div>
        <div class="row"><label>Roughness</label><input id="glassRoughNum" type="number" step="0.01"><input id="glassRough" type="range" min="0.0" max="1.0" step="0.01"></div>
        <div class="row"><label>Clearcoat</label><input id="glassCCNum" type="number" step="0.01"><input id="glassCC" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>CC Roughness</label><input id="glassCCRNum" type="number" step="0.01"><input id="glassCCR" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>Env Intensity</label><input id="glassEnvNum" type="number" step="0.01"><input id="glassEnv" type="range" min="0" max="4" step="0.01"></div>
        <div class="row"><label>Metalness</label><input id="glassMetalNum" type="number" step="0.01"><input id="glassMetal" type="range" min="0" max="1" step="0.01"></div>

        <h3>Base Color (RGB 0..1)</h3>
        <div class="inline swatch">
          <input id="glassColR" type="number" min="0" max="1" step="0.01">
          <input id="glassColG" type="number" min="0" max="1" step="0.01">
          <input id="glassColB" type="number" min="0" max="1" step="0.01">
        </div>

        <h3>Transmission Tint (RGB 0..1)</h3>
        <div class="inline swatch">
          <input id="glassAttR" type="number" min="0" max="1" step="0.01">
          <input id="glassAttG" type="number" min="0" max="1" step="0.01">
          <input id="glassAttB" type="number" min="0" max="1" step="0.01">
        </div>
      </div>

      <!-- Header + Badges -->
      <div class="tabpage" id="headerTab">
        <h3>Header Text</h3>
        <div class="hint">Opacity is automatic: starts at 0 and eases to 0.99 when the vase reaches full spin speed (then stays).</div>
        <div class="row"><label>Size ×</label><input id="hdrSizeNum" type="number" step="0.01" min="0.2" max="3"><input id="hdrSize" type="range" min="0.2" max="3" step="0.01"></div>
        <div class="row"><label>Pos X</label><input id="hdrXNum" type="number" step="0.1"><input id="hdrX" type="range" min="-40" max="40" step="0.1"></div>
        <div class="row"><label>Pos Y</label><input id="hdrYNum" type="number" step="0.1"><input id="hdrY" type="range" min="-20" max="20" step="0.1"></div>
        <div class="row"><label>Pos Z</label><input id="hdrZNum" type="number" step="0.1"><input id="hdrZ" type="range" min="-40" max="40" step="0.1"></div>

        <h3>Header Material</h3>
        <div class="row"><label>Metalness</label><input id="hdrMetalNum" type="number" step="0.01"><input id="hdrMetal" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>Roughness</label><input id="hdrRoughNum" type="number" step="0.01"><input id="hdrRough" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>Clearcoat</label><input id="hdrCCNum" type="number" step="0.01"><input id="hdrCC" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>CC Roughness</label><input id="hdrCCRNum" type="number" step="0.01"><input id="hdrCCR" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>Env Intensity</label><input id="hdrEnvNum" type="number" step="0.01"><input id="hdrEnv" type="range" min="0" max="4" step="0.01"></div>
        <div class="row"><label>Transmission</label><input id="hdrTransNum" type="number" step="0.01"><input id="hdrTrans" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>Depth/Thickness ×</label><input id="hdrThickNum" type="number" step="0.01"><input id="hdrThick" type="range" min="0.2" max="3" step="0.01"></div>
        <div class="row"><label>Emissive Intensity</label><input id="hdrEmissNum" type="number" step="0.01"><input id="hdrEmiss" type="range" min="0" max="3" step="0.01"></div>

        <h3>Badges</h3>
        <div class="row"><label>Badge Size ×</label><input id="bdgSizeNum" type="number" step="0.01"><input id="bdgSize" type="range" min="0.3" max="3" step="0.01"></div>
        <div class="row"><label>Thickness ×</label><input id="bdgThickNum" type="number" step="0.01"><input id="bdgThick" type="range" min="0.5" max="4" step="0.01"></div>
        <div class="row"><label>X Offset ×</label><input id="bdgXOffNum" type="number" step="0.01"><input id="bdgXOff" type="range" min="0" max="2" step="0.01"></div>
        <div class="row"><label>Height ×</label><input id="bdgHeightNum" type="number" step="0.01"><input id="bdgHeight" type="range" min="0" max="4" step="0.01"></div>
        <div class="row"><label>Z Offset</label><input id="bdgZOffNum" type="number" step="0.1"><input id="bdgZOff" type="range" min="-10" max="10" step="0.1"></div>
      </div>
    </div>
  </div>

  <button id="toggleControls">Controls (H)</button>
  <button id="enableMotion">Enable Fun</button>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { TTFLoader } from 'three/addons/loaders/TTFLoader.js';
    import { Font } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

    const vw = ()=> (window.visualViewport?.width  || window.innerWidth);
    const vh = ()=> (window.visualViewport?.height || window.innerHeight);
    const isPortrait = ()=> vh() >= vw();
    const isTouch = ()=> ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    const isPhone = ()=> isTouch() && (Math.min(vw(), vh()) < 820);

    const params = new URLSearchParams(location.search);
    function getStoredPreset(){ try{ return localStorage.getItem('room_preset_override') || ''; }catch(_){ return ''; } }
    function setStoredPreset(v){ try{ localStorage.setItem('room_preset_override', v); }catch(_){ } }
    const urlPreset = (params.get('preset')||'').toLowerCase();
    if (urlPreset === 'phone' || urlPreset === 'desktop') setStoredPreset(urlPreset);
    const presetChoice = getStoredPreset() || (isPhone() ? 'phone' : 'desktop');

    /* -------------------- presets from you -------------------- */
    const desktopDefaults = {
      room: {
        width: 18.766829958988648,
        height: 10.18770767198562,
        depth: 14.5,
        positionZ: -10.8,
        imageZoom: 0.96,
        borderOpacity: 0,
        wallEmissive: 0.38,
        wallDispAmp: 0.006,
        wallDispSpeed: 2.39
      },
      lights: {
        exposure: 0.86,
        ambient: 1.91,
        hemisphere: 2,
        rim: 1.87,
        key: 1.68,
        vaseLight: {
          intensity: 6,
          distance: 8.6,
          decay: 1.6,
          y: 0.1
        }
      },
      vase: {
        userScaleMult: 3.2,
        userTallY: 1.06,
        z: -10.7,
        y: -4.8
      },
      spin: {
        damping: 0.997,
        minSpin: 0.11,
        swipeImpulse: 0.02
      },
      post: {
        pixelSize: 5,
        ditherStrength: 1
      },
      water: {
        amp: 1.61,
        freq: 40,
        speed: 0.82,
        falloff: 0.9,
        alpha: 0.44,
        radius: 2.9,
        pixel: 24,
        yOffset: -0.05,
        tint: [0.45, 0.75, 1]
      },
      glass: {
        transmission: 0.86,
        thickness: 4,
        ior: 2.5,
        roughness: 0.05,
        clearcoat: 1,
        ccRough: 0.9,
        envIntensity: 1.51,
        metalness: 0.63,
        color: [1, 1, 1],
        attnColor: [0.66, 0.79, 1]
      },
      _internal: {
        WATER_RADIUS_FACTOR: 0.74,
        TILT_MARGIN: 1.1247358823385865
      },
      header: {
        opacity: 0.99,
        sizeMul: 0.56,
        x: 0,
        y: 2.5,
        z: -2.5,
        locked: true,
        metalness: 0.97,
        roughness: 0.0,
        clearcoat: 0.12,
        clearcoatRoughness: 0.84,
        envIntensity: 2.47,
        transmission: 1,
        thickness: 2,
        emissiveIntensity: 1
      },
      badges: {
        sizeMul: 1.53,
        thicknessMul: 2.8,
        offsetXMul: 1.01,
        heightMul: 1.6,
        zOffset: 1.4,
        forceVisible: false,
        activated: true
      },
      _preset: 'desktop'
    };

    const phoneDefaults = {
      room: {
        width: 3.2466138193122998,
        height: 7.026005291024567,
        depth: 6.6,
        positionZ: -10.4,
        imageZoom: 0.96,
        borderOpacity: 0,
        wallEmissive: 0.32,
        wallDispAmp: 0.011,
        wallDispSpeed: 2.19
      },
      lights: {
        exposure: 0.77,
        ambient: 0.79,
        hemisphere: 2.87,
        rim: 3.34,
        key: 1.47,
        vaseLight: {
          intensity: 10.26,
          distance: 2.9,
          decay: 2.5,
          y: 0.77
        }
      },
      vase: {
        userScaleMult: 0.98,
        userTallY: 1.04,
        z: -9.3,
        y: -3.1
      },
      spin: {
        damping: 0.997,
        minSpin: 0.11,
        swipeImpulse: 0.02
      },
      post: {
        pixelSize: 5,
        ditherStrength: 1
      },
      water: {
        amp: 0,
        freq: 23.9,
        speed: 0.82,
        falloff: 0.9,
        alpha: 0.44,
        radius: 2.9,
        pixel: 24,
        yOffset: -0.05,
        tint: [0.45, 0.75, 1]
      },
      glass: {
        transmission: 0.98,
        thickness: 2.98,
        ior: 2.5,
        roughness: 0,
        clearcoat: 0.03,
        ccRough: 0.67,
        envIntensity: 1.58,
        metalness: 0.8,
        color: [1, 1, 1],
        attnColor: [0.66, 0.79, 1]
      },
      _internal: {
        WATER_RADIUS_FACTOR: 0.74,
        TILT_MARGIN: 1.1247358823385865
      },
      header: {
        opacity: 0.99,
        sizeMul: 0.74,
        x: -2.3,
        y: -4.3,
        z: 7.6,
        locked: true,
        metalness: 0.15,
        roughness: 0.07,
        clearcoat: 0.46,
        clearcoatRoughness: 0.74,
        envIntensity: 2.18,
        transmission: 1,
        thickness: 2,
        emissiveIntensity: 1
      },
      badges: {
        sizeMul: 1.13,
        thicknessMul: 2.91,
        offsetXMul: 0.4,
        heightMul: 2,
        zOffset: 2.8,
        forceVisible: false,
        activated: true
      },
      _preset: 'phone'
    };

    const CONFIG = structuredClone(presetChoice === 'phone' ? phoneDefaults : desktopDefaults);

    /* -------------------- renderer & scene -------------------- */
    const renderer = new THREE.WebGLRenderer({
      antialias:true,
      alpha:true,
      powerPreference:'high-performance'
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, isPhone() ? 1.5 : 1.8));
    renderer.setSize(vw(), vh(), false);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = CONFIG.lights.exposure;
    renderer.setClearColor(0x000000, 1);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0d1220, 18, 40);

    const camera = new THREE.PerspectiveCamera(55, vw()/vh(), 0.1, 100);
    camera.position.set(0, 0, 7.5);

    /* -------------------- wall texture & shader -------------------- */
    const textureURL = "/reilly-album-cvr.jpeg";
    const tLoader = new THREE.TextureLoader(); tLoader.setCrossOrigin("anonymous");
    const tex = tLoader.load(textureURL, ()=>{
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      applyTextureZoom(tex, CONFIG.room.imageZoom);
    });

    const wallMat = new THREE.MeshStandardMaterial({
      map: tex,
      side: THREE.BackSide,
      roughness: 0.8,
      metalness: 0.0,
      emissive: new THREE.Color(0x2a365c),
      emissiveIntensity: CONFIG.room.wallEmissive,
      envMapIntensity: 0.18
    });

    let wallShaderRef = null;
    wallMat.onBeforeCompile = (shader)=>{
      shader.fragmentShader = shader.fragmentShader.replace(
        '#include <common>',
        `#include <common>
         uniform float uTime;
         uniform float uDispAmp;
         uniform float uDispSpeed;`
      );
      shader.fragmentShader = shader.fragmentShader.replace(
        '#include <map_fragment>',
        `#ifdef USE_MAP
          vec2 uv2 = vMapUv;
          float g = 120.0;
          vec2 grid = floor(uv2 * g)/g;
          float t = uTime * uDispSpeed;
          vec2 warp = vec2(
            sin(grid.y*40.0 + t*2.2),
            cos(grid.x*40.0 - t*1.7)
          ) * uDispAmp;
          vec4 sampledDiffuseColor = texture2D(map, uv2 + warp);
          diffuseColor *= sampledDiffuseColor;
        #endif`
      );
      shader.uniforms.uTime      = { value: 0.0 };
      shader.uniforms.uDispAmp   = { value: CONFIG.room.wallDispAmp };
      shader.uniforms.uDispSpeed = { value: CONFIG.room.wallDispSpeed };
      wallShaderRef = shader;
    };

    function applyTextureZoom(texture, z=1.0){
      const r = 1 / Math.max(z, 0.0001);
      texture.center.set(0.5, 0.5);
      texture.repeat.set(r, r);
      texture.offset.set((1 - r) * 0.5, (1 - r) * 0.5);
      texture.needsUpdate = true;
    }

    /* -------------------- room geometry & autofit -------------------- */
    let ROOM_W=CONFIG.room.width, ROOM_H=CONFIG.room.height, ROOM_D=CONFIG.room.depth;

    function buildRoomGeometry(w, h, d){
      const geo = new THREE.BoxGeometry(w, h, d, 1, 1, 1);
      const tileW = 1/4, tileH = 1/3;
      const regions = {
        px:{u0:0.5,v0:1/3},
        nx:{u0:0.0,v0:1/3},
        py:{u0:0.25,v0:2/3},
        ny:{u0:0.25,v0:0.0},
        pz:{u0:0.25,v0:1/3},
        nz:{u0:0.75,v0:1/3}
      };
      const uv = geo.getAttribute('uv'); const arr = uv.array; const stride = 12;
      const faces=[regions.px,regions.nx,regions.py,regions.ny,regions.pz,regions.nz];
      const put=(off,u0,v0,u1,v1,flipH)=>{
        let A=[u0,v0],B=[u1,v0],C=[u1,v1],D=[u0,v1];
        if (flipH){ [A,B,C,D]=[[B[0],B[1]],[A[0],A[1]],[D[0],D[1]],[C[0],C[1]]]; }
        const uvs=[A[0],A[1], B[0],B[1], D[0],D[1],  B[0],B[1], C[0],C[1], D[0],D[1]];
        for(let i=0;i<12;i++) arr[off+i]=uvs[i];
      };
      for(let f=0; f<6; f++){
        const r=faces[f]; const u0=r.u0, v0=r.v0, u1=u0+tileW, v1=v0+tileH;
        put(f*stride,u0,v0,u1,v1,true);
      }
      uv.needsUpdate = true; return geo;
    }

    const roomGeo = buildRoomGeometry(ROOM_W, ROOM_H, ROOM_D);
    const room = new THREE.Mesh(roomGeo, wallMat);
    room.position.set(0, 0, CONFIG.room.positionZ);
    scene.add(room);

    const edges = new THREE.LineSegments(
      new THREE.EdgesGeometry(roomGeo),
      new THREE.LineBasicMaterial({
        color: 0xF0F6FF,
        transparent: true,
        opacity: CONFIG.room.borderOpacity
      })
    );
    edges.position.copy(room.position);
    scene.add(edges);

    const BASE_VFOV_DEG = 55;
    const INPUT_MAX_TILT = 0.085;
    let WATER_RADIUS_FACTOR = CONFIG._internal?.WATER_RADIUS_FACTOR ?? 0.74;
    let TILT_MARGIN = CONFIG._internal?.TILT_MARGIN ?? (1.12 / Math.cos(INPUT_MAX_TILT * 1.08));

    function computeTargetDistance(depth){
      return THREE.MathUtils.clamp(depth * 0.6, 6.0, 20.0);
    }

    function rebuildRoom(){
      const newGeo = buildRoomGeometry(ROOM_W, ROOM_H, ROOM_D);
      room.geometry.dispose(); room.geometry=newGeo;
      edges.geometry.dispose(); edges.geometry=new THREE.EdgesGeometry(newGeo);
      resizeWater();
      rebuildWaterCircle();
    }

    function adjustRoomToViewport(){
      const aspect = vw()/vh();
      const vfovRad = THREE.MathUtils.degToRad(BASE_VFOV_DEG);
      const openingZ = room.position.z + ROOM_D * 0.5;
      const dTarget  = computeTargetDistance(ROOM_D);

      camera.fov = BASE_VFOV_DEG;
      camera.aspect = aspect;
      camera.position.set(0, 0, openingZ + dTarget);

      const halfH = Math.tan(vfovRad * 0.5) * dTarget;
      const targetH = 2 * halfH * TILT_MARGIN;
      const targetW = targetH * aspect;

      ROOM_H = targetH;
      ROOM_W = targetW;
      rebuildRoom();

      const backZ = room.position.z - ROOM_D * 0.5;
      const margin = Math.max(0.5, Math.min(5, ROOM_D * 0.25));
      camera.near = Math.max(0.01, (camera.position.z - openingZ) * 0.25);
      camera.far  = Math.max(50, (camera.position.z - backZ) + margin);
      camera.updateProjectionMatrix();

      if (headerFontRef) rebuildHeaderGeometry();
    }

    /* -------------------- lights -------------------- */
    const amb = new THREE.AmbientLight(0xffffff, CONFIG.lights.ambient); scene.add(amb);
    const hemi = new THREE.HemisphereLight(0x9fbfff, 0x202a44, CONFIG.lights.hemisphere); scene.add(hemi);
    const rim = new THREE.DirectionalLight(0xeef3ff, CONFIG.lights.rim); rim.position.set(-1.4, 2.2, 1.6); scene.add(rim);
    const key = new THREE.PointLight(0xffffff, CONFIG.lights.key, 18, 2.0);
    key.position.set(1.5, -ROOM_H*0.1, room.position.z + ROOM_D*0.05);
    scene.add(key);

    /* -------------------- env map & vase -------------------- */
    const cubeRT = new THREE.WebGLCubeRenderTarget(256, {
      generateMipmaps:true,
      minFilter:THREE.LinearMipmapLinearFilter,
      magFilter:THREE.LinearFilter
    });
    cubeRT.texture.colorSpace = THREE.SRGBColorSpace;
    const cubeCam = new THREE.CubeCamera(0.1, 100, cubeRT);
    scene.add(cubeCam);

    const vaseGroup = new THREE.Group(); scene.add(vaseGroup);
    const vaseLight = new THREE.PointLight(
      0xaad4ff,
      CONFIG.lights.vaseLight.intensity,
      CONFIG.lights.vaseLight.distance,
      CONFIG.lights.vaseLight.decay
    );
    vaseLight.position.set(0, CONFIG.lights.vaseLight.y, 0);
    vaseGroup.add(vaseLight);

    let vase=null, vaseReady=false, vaseBaseScale=1, userScaleMult=CONFIG.vase.userScaleMult, userTallY=CONFIG.vase.userTallY;
    const glassMaterials = [];

    const VASE_URL = "./vaseNew.glb";
    const gltf = new GLTFLoader();
    gltf.load(VASE_URL, g=>{
      vase = g.scene;

      const baseGlass = {
        color: new THREE.Color().setRGB(...CONFIG.glass.color),
        metalness: CONFIG.glass.metalness,
        roughness: CONFIG.glass.roughness,
        transmission: CONFIG.glass.transmission,
        thickness: CONFIG.glass.thickness,
        ior: CONFIG.glass.ior,
        clearcoat: CONFIG.glass.clearcoat,
        clearcoatRoughness: CONFIG.glass.ccRough,
        attenuationColor: new THREE.Color().setRGB(...CONFIG.glass.attnColor),
        attenuationDistance: 2.0,
        envMap: cubeRT.texture,
        envMapIntensity: CONFIG.glass.envIntensity
      };

      vase.traverse(n=>{
        if(n.isMesh){
          const m = new THREE.MeshPhysicalMaterial(baseGlass);
          n.castShadow = n.receiveShadow = false;
          // tiny emissive so it's never pure black on load
          m.emissive.setRGB(0.02, 0.03, 0.06);
          m.emissiveIntensity = 0.08;
          glassMaterials.push(m);
          n.material = m;
        }
      });

      vaseBaseScale = autoScaleToRoom(vase);
      applyVaseScale();
      vaseGroup.add(vase);
      placeOnFloor(vaseGroup);
      vaseGroup.position.set(0, CONFIG.vase.y, CONFIG.vase.z);
      vaseReady = true;
      syncVasePositionInputs();
    });

    function applyGlassConfigToMaterials(){
      for (const m of glassMaterials){
        m.transmission       = CONFIG.glass.transmission;
        m.thickness          = CONFIG.glass.thickness;
        m.ior                = CONFIG.glass.ior;
        m.roughness          = CONFIG.glass.roughness;
        m.clearcoat          = CONFIG.glass.clearcoat;
        m.clearcoatRoughness = CONFIG.glass.ccRough;
        m.envMapIntensity    = CONFIG.glass.envIntensity;
        m.metalness          = CONFIG.glass.metalness;
        m.color.setRGB(...CONFIG.glass.color);
        m.attenuationColor.setRGB(...CONFIG.glass.attnColor);
        m.envMap             = cubeRT.texture;
        m.needsUpdate        = true;
      }
    }

    function roomFloorY(){ return -ROOM_H * 0.5 + 0.02; }
    function placeOnFloor(obj){
      obj.updateMatrixWorld(true);
      const bbox = new THREE.Box3().setFromObject(obj);
      const floorY = roomFloorY();
      obj.position.y += (floorY - bbox.min.y);
    }
    function autoScaleToRoom(obj){
      const bbox = new THREE.Box3().setFromObject(obj);
      const size = new THREE.Vector3(); bbox.getSize(size);
      const maxTarget = Math.min(ROOM_H * 0.38, ROOM_W * 0.38);
      return maxTarget / Math.max(size.x, size.y, size.z);
    }
    function applyVaseScale(){
      if(!vase) return;
      const portraitBoost = (isPortrait() && (presetChoice==='phone')) ? 1.7 : 1.0;
      const s = vaseBaseScale * portraitBoost * userScaleMult;
      vase.scale.set(s, s*userTallY, s);
    }

    /* -------------------- header 3D text -------------------- */
    const HEADER_TEXT = 'Biome .•.•.•:::Plain.';
    const FONT_URL = './Sprintura.otf';

    const headerGroup = new THREE.Group();
    scene.add(headerGroup);
    let headerMesh = null;
    let headerMat = null;
    let headerFontRef = null;

    const headerConfig = {
      sizeMul: (CONFIG.header?.sizeMul ?? 1.0),
      x: CONFIG.header?.x ?? 0,
      y: CONFIG.header?.y ?? 2.0,
      z: CONFIG.header?.z ?? 6.0,
      metalness: CONFIG.header?.metalness ?? 1.0,
      roughness: CONFIG.header?.roughness ?? 0.18,
      clearcoat: CONFIG.header?.clearcoat ?? 1.0,
      clearcoatRoughness: CONFIG.header?.clearcoatRoughness ?? 0.35,
      envIntensity: CONFIG.header?.envIntensity ?? 1.6,
      transmission: CONFIG.header?.transmission ?? 0.32,
      thickness: CONFIG.header?.thickness ?? 1.0,
      emissiveIntensity: CONFIG.header?.emissiveIntensity ?? 0.32
    };

    let headerOpacityLocked = false;
    const HEADER_OPACITY_MAX = 0.99;

    function headerBaseSize(){ return Math.min(ROOM_W, ROOM_H) * 0.145; }
    function headerBaseHeight(){ return Math.min(ROOM_W, ROOM_H) * 0.035; }

    function buildHeaderMaterial(){
      headerMat = new THREE.MeshPhysicalMaterial({
        color: 0xCFE0FF,
        metalness: headerConfig.metalness,
        roughness: headerConfig.roughness,
        clearcoat: headerConfig.clearcoat,
        clearcoatRoughness: headerConfig.clearcoatRoughness,
        envMap: cubeRT.texture,
        envMapIntensity: headerConfig.envIntensity,
        transmission: headerConfig.transmission,
        thickness: headerConfig.thickness,
        reflectivity: 1.0,
        ior: 1.45,
        side: THREE.FrontSide,
        transparent: true,
        opacity: 0.0,          // start fully invisible
        depthTest: false,
        depthWrite: false,
        emissive: new THREE.Color(0x6f8bbf),
        emissiveIntensity: headerConfig.emissiveIntensity
      });
      return headerMat;
    }

    function applyHeaderTransform(){
      headerGroup.position.set(headerConfig.x, headerConfig.y, headerConfig.z);
    }

    function rebuildHeaderGeometry(){
      if (!headerFontRef) return;
      if (headerMesh){
        headerGroup.remove(headerMesh);
        headerMesh.geometry.dispose();
      }
      const sizeBase = headerBaseSize();
      const heightBase = headerBaseHeight();

      const geo = new TextGeometry(HEADER_TEXT, {
        font: headerFontRef,
        size: sizeBase * headerConfig.sizeMul,
        height: heightBase * headerConfig.sizeMul * headerConfig.thickness,
        curveSegments: 10,
        bevelEnabled: true,
        bevelThickness: Math.min(ROOM_W, ROOM_H) * 0.003 * headerConfig.sizeMul * headerConfig.thickness,
        bevelSize:      Math.min(ROOM_W, ROOM_H) * 0.002 * headerConfig.sizeMul * headerConfig.thickness,
        bevelSegments: 4
      });
      geo.computeBoundingBox();
      geo.center();

      if (!headerMat) buildHeaderMaterial();
      headerMesh = new THREE.Mesh(geo, headerMat);
      headerMesh.castShadow = headerMesh.receiveShadow = false;
      headerMesh.renderOrder = 999;

      headerGroup.add(headerMesh);
      applyHeaderTransform();
    }

    const ttfLoader = new TTFLoader();
    ttfLoader.load(FONT_URL, (json)=>{
      const font = new Font(json);
      headerFontRef = font;
      if (!CONFIG.header){
        const openingZ = room.position.z + ROOM_D * 0.5;
        const dTarget  = computeTargetDistance(ROOM_D);
        headerConfig.x = 0;
        headerConfig.y = ROOM_H * 0.2;
        headerConfig.z = openingZ + dTarget * 0.35;
      }
      buildHeaderMaterial();
      rebuildHeaderGeometry();
    });

    /* -------------------- spin physics & full-speed hold -------------------- */
    let angVel=0, tilt=0, wobblePhase=0;
    let DAMPING=CONFIG.spin.damping, MIN_SPIN=CONFIG.spin.minSpin, IMPULSE_SCALE=CONFIG.spin.swipeImpulse;

    const FULL_SPIN_SPEED = (presetChoice==='phone') ? 6.0 : 5.0;
    const FULL_SPEED_HOLD_SECS = 10.0;    // 10s full-speed hold
    let fullSpeedHoldUntil = 0.0;

    const SPEED_REF = FULL_SPIN_SPEED * 1.2;
    const TILT_IDLE_DEG = 45;
    const TILT_MIN_DEG  = 10;

    let dragging=false, lastX=0, lastT=0;
    function getPointerX(e){
      if(e.touches?.length) return e.touches[0].clientX;
      if(e.changedTouches?.length) return e.changedTouches[0].clientX;
      return e.clientX ?? 0;
    }
    function onSwipeDown(e){
      dragging=true;
      lastX=getPointerX(e);
      lastT=performance.now();
      maybeStartAudio();
    }
    function onSwipeMove(e){
      if(!dragging) return;
      const now=performance.now();
      const x=getPointerX(e);
      const dx=x-lastX;
      const dt=Math.max(1, now-lastT);
      angVel += (dx/dt)*IMPULSE_SCALE;
      lastX=x;
      lastT=now;
    }
    function onSwipeUp(){ dragging=false; }

    window.addEventListener('mousedown', onSwipeDown, {passive:true});
    window.addEventListener('mousemove', onSwipeMove, {passive:true});
    window.addEventListener('mouseup',   onSwipeUp,   {passive:true});
    window.addEventListener('touchstart',onSwipeDown, {passive:true});
    window.addEventListener('touchmove', onSwipeMove, {passive:true});
    window.addEventListener('touchend',  onSwipeUp,   {passive:true});

    function updateVase(dt, timeSec){
      if(!vaseReady) return;

      const speedAbsBefore = Math.abs(angVel);
      if (speedAbsBefore >= FULL_SPIN_SPEED * 0.98){
        fullSpeedHoldUntil = timeSec + FULL_SPEED_HOLD_SECS;
      }
      const inHold = timeSec < fullSpeedHoldUntil;
      const sign = (angVel>=0 ? 1 : -1) || 1;

      if (inHold){
        // converge to exact full speed
        const target = FULL_SPIN_SPEED;
        angVel += (sign*target - angVel) * Math.min(1, dt*5.0);
      } else {
        // normal damping + floor
        angVel *= Math.pow(DAMPING, dt*60);
        const floor = (angVel>=0 ? MIN_SPIN : -MIN_SPIN);
        if (Math.abs(angVel) < Math.abs(floor)) angVel = floor;
      }

      // safety clamp
      const maxSpin = FULL_SPIN_SPEED * 1.6;
      if (Math.abs(angVel) > maxSpin) angVel = Math.sign(angVel) * maxSpin;

      const speedNorm = Math.min(1, Math.abs(angVel)/SPEED_REF);
      const targetTilt = THREE.MathUtils.degToRad(
        THREE.MathUtils.lerp(TILT_IDLE_DEG, TILT_MIN_DEG, speedNorm)
      );
      tilt += (targetTilt - tilt) * Math.min(1, dt*3.0);

      const wobbleAmp = THREE.MathUtils.lerp(0.11, 0.03, speedNorm);
      const wobbleFreq = THREE.MathUtils.lerp(0.8, 3.2, speedNorm);
      wobblePhase += wobbleFreq * dt;

      vaseGroup.rotation.y += angVel * dt;
      vaseGroup.rotation.x = tilt + Math.sin(wobblePhase) * wobbleAmp;
      vaseGroup.rotation.z = Math.cos(wobblePhase*0.9) * (wobbleAmp * 0.6);
    }

    /* -------------------- pointer / gyro tilt -------------------- */
    const enableMotionBtn = document.getElementById('enableMotion');
    let targetRX=0, targetRY=0;
    let baseBeta=null, baseGamma=null, pointerMoveAttached=false;

    function onPointerMoveDesktop(e){
      const x=(e.clientX/vw())*2-1, y=(e.clientY/vh())*2-1;
      targetRY = x*0.085;
      targetRX = -y*0.085*0.6;
    }
    function onDeviceOrientation(e){
      if (baseBeta===null) baseBeta=e.beta||0;
      if (baseGamma===null) baseGamma=e.gamma||0;
      const dB=(e.beta||0)-baseBeta, dG=(e.gamma||0)-baseGamma;
      targetRY = THREE.MathUtils.clamp(dG/45,-1,1)*0.085;
      targetRX = -THREE.MathUtils.clamp(dB/60,-1,1)*0.085*0.6;
    }
    function setupInputMode(){
      if (pointerMoveAttached){
        window.removeEventListener('pointermove', onPointerMoveDesktop);
        pointerMoveAttached=false;
      }
      window.removeEventListener('deviceorientation', onDeviceOrientation, true);
      enableMotionBtn.style.display = 'none';
      if (isPortrait() && (presetChoice==='phone') && window.DeviceOrientationEvent){
        const needsPerm = typeof DeviceOrientationEvent.requestPermission === 'function';
        if (needsPerm){
          enableMotionBtn.style.display = 'block';
          enableMotionBtn.onclick = async ()=>{
            try {
              const resp=await DeviceOrientationEvent.requestPermission();
              if(resp==='granted'){
                window.addEventListener('deviceorientation', onDeviceOrientation, true);
                enableMotionBtn.remove();
              }
            } catch(e){ console.warn(e); }
            maybeStartAudio(true);
          };
        } else {
          window.addEventListener('deviceorientation', onDeviceOrientation, true);
        }
      } else {
        window.addEventListener('pointermove', onPointerMoveDesktop, {passive:true});
        pointerMoveAttached=true;
      }
    }

    /* -------------------- postprocess -------------------- */
    let rt = new THREE.WebGLRenderTarget(
      vw(), vh(),
      { minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, depthBuffer:true, stencilBuffer:false }
    );
    const screenScene = new THREE.Scene();
    const screenCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);

    const fsMat = new THREE.ShaderMaterial({
      uniforms:{
        tDiffuse: { value: rt.texture },
        resolution: { value: new THREE.Vector2(vw(), vh()) },
        pixelSize: { value: CONFIG.post.pixelSize },
        ditherStrength: { value: CONFIG.post.ditherStrength }
      },
      vertexShader: `varying vec2 vUv; void main(){ vUv = uv; gl_Position = vec4(position, 1.0); }`,
      fragmentShader: `
        precision highp float;
        uniform sampler2D tDiffuse;
        uniform vec2 resolution;
        uniform float pixelSize;
        uniform float ditherStrength;
        varying vec2 vUv;
        float bayer(vec2 p){
          int x = int(mod(p.x, 4.0));
          int y = int(mod(p.y, 4.0));
          int m[16];
          m[0]=0; m[1]=8; m[2]=2; m[3]=10;
          m[4]=12; m[5]=4; m[6]=14; m[7]=6;
          m[8]=3; m[9]=11; m[10]=1; m[11]=9;
          m[12]=15; m[13]=7; m[14]=13; m[15]=5;
          int idx = y*4 + x;
          return float(m[idx]) / 16.0;
        }
        void main(){
          vec2 px = vec2(max(1.0, pixelSize));
          vec2 uv = floor(vUv * resolution / px) * px / resolution;
          vec3 col = texture2D(tDiffuse, uv).rgb;
          float luma = dot(col, vec3(0.2126,0.7152,0.0722));
          vec2 grid = floor(vUv * resolution / px);
          float thresh = bayer(grid);
          float d = smoothstep(0.0, 1.0, luma + (thresh - 0.5) * ditherStrength);
          col = mix(col*0.9, col*1.1, d);
          gl_FragColor = vec4(col, 1.0);
        }
      `
    });
    const fsQuad = new THREE.Mesh(new THREE.PlaneGeometry(2,2), fsMat);
    screenScene.add(fsQuad);

    function resizePost(){
      rt.setSize(vw(), vh());
      fsMat.uniforms.resolution.value.set(vw(), vh());
    }

    /* -------------------- water -------------------- */
    const waterUniforms = {
      uTime: { value: 0 },
      uCenter: { value: new THREE.Vector3(0, 0, 0) },
      uAmp: { value: CONFIG.water.amp },
      uFreq: { value: CONFIG.water.freq },
      uSpeed: { value: CONFIG.water.speed },
      uFalloff: { value: CONFIG.water.falloff },
      uAlpha: { value: CONFIG.water.alpha },
      uRadius: { value: CONFIG.water.radius },
      uPixel: { value: CONFIG.water.pixel },
      uColor: { value: new THREE.Color().setRGB(...CONFIG.water.tint) },
      uSpinAbs: { value: 0 }
    };

    const waterMat = new THREE.ShaderMaterial({
      transparent:true, depthWrite:false, depthTest:true, blending: THREE.AdditiveBlending,
      uniforms: waterUniforms,
      vertexShader: `
        varying vec3 vWorld;
        varying vec2 vUv;
        void main(){
          vUv = uv;
          vec4 wp = modelMatrix * vec4(position, 1.0);
          vWorld = wp.xyz;
          gl_Position = projectionMatrix * viewMatrix * wp;
        }
      `,
      fragmentShader: `
        precision highp float;
        varying vec3 vWorld;
        varying vec2 vUv;
        uniform vec3  uCenter;
        uniform float uTime, uAmp, uFreq, uSpeed, uFalloff, uAlpha, uRadius, uPixel, uSpinAbs;
        uniform vec3  uColor;
        vec2 pix(vec2 uv){ float p = max(1.0, uPixel); return floor(uv * p) / p; }
        void main(){
          vec2  p  = vWorld.xz - uCenter.xz;
          float d  = length(p);
          float nd = clamp(d / uRadius, 0.0, 1.0);
          float w = sin(d * uFreq - (uTime * (uSpeed * (1.0 + uSpinAbs*2.0))));
          float fall = exp(-nd * uFalloff * 4.0);
          float h = w * uAmp * (0.5 + uSpinAbs*1.4) * fall;
          float ring = smoothstep(0.0, 1.0, abs(w));
          vec3  col  = uColor * (0.6 + 1.6 * h + 0.5 * ring);
          float a    = clamp(uAlpha * (0.35 + 0.9 * h + 0.25 * ring), 0.0, 1.0);
          vec2 uvq = pix(vUv);
          col *= (0.9 + 0.2 * fract(uvq.x * 128.0 + uvq.y * 96.0));
          gl_FragColor = vec4(col, a);
        }
      `
    });

    const waterGeo = new THREE.CircleGeometry(1.0, 128);
    const waterMesh = new THREE.Mesh(waterGeo, waterMat);
    waterMesh.rotation.x = -Math.PI/2;
    room.add(waterMesh);

    function rebuildWaterCircle(){
      const radius = Math.max(ROOM_W, ROOM_D) * WATER_RADIUS_FACTOR;
      waterMesh.geometry.dispose();
      waterMesh.geometry = new THREE.CircleGeometry(radius, 128);
    }
    function resizeWater(){
      waterMesh.position.set(0, -ROOM_H*0.5 + 0.07 + CONFIG.water.yOffset, 0);
    }
    rebuildWaterCircle();
    resizeWater();

    function updateWaterCenterFromVase(){
      if(!vaseReady) return;
      const world = new THREE.Vector3();
      vaseGroup.getWorldPosition(world);
      const waterY = waterMesh.getWorldPosition(new THREE.Vector3()).y;
      waterUniforms.uCenter.value.set(world.x, waterY, world.z);
    }

    /* -------------------- badges (3D cards, PNG alpha) -------------------- */
    const badgeGroup = new THREE.Group();
    scene.add(badgeGroup);
    badgeGroup.visible = false;

    let spotifyTex = null;
    let appleTex = null;
    let spotifyBadge = null;
    let appleBadge = null;
    let badgesReady = false;
    let badgesActivated = false; // only becomes true at full speed

    const badgesConfig = CONFIG.badges ? {
      sizeMul: CONFIG.badges.sizeMul ?? 1.0,
      thicknessMul: CONFIG.badges.thicknessMul ?? 2.8,
      offsetXMul: CONFIG.badges.offsetXMul ?? 1.0,
      heightMul: CONFIG.badges.heightMul ?? 1.0,
      zOffset: CONFIG.badges.zOffset ?? 0.0
    } : {
      sizeMul: 1.0,
      thicknessMul: 2.8,
      offsetXMul: 1.0,
      heightMul: 1.0,
      zOffset: 0.0
    };

    function buildBadges(){
      const loader = new THREE.TextureLoader();
      loader.setCrossOrigin('anonymous');

      spotifyTex = loader.load('./spotify.png', t=>{
        t.colorSpace = THREE.SRGBColorSpace;
        t.magFilter = THREE.LinearFilter;
        t.minFilter = THREE.LinearMipmapLinearFilter;
        t.anisotropy = renderer.capabilities.getMaxAnisotropy();
      });
      appleTex = loader.load('./apple.png', t=>{
        t.colorSpace = THREE.SRGBColorSpace;
        t.magFilter = THREE.LinearFilter;
        t.minFilter = THREE.LinearMipmapLinearFilter;
        t.anisotropy = renderer.capabilities.getMaxAnisotropy();
      });

      const geo = new THREE.BoxGeometry(1,1,1);

      const makeBadgeMaterials = (mapTex)=>{
        const mat = new THREE.MeshStandardMaterial({
          map: mapTex,
          metalness: 0.3,
          roughness: 0.35,
          envMap: cubeRT.texture,
          envMapIntensity: 1.2,
          transparent: true,
          alphaTest: 0.01
        });
        // same material on all faces (no black box)
        return [mat, mat, mat, mat, mat, mat];
      };

      spotifyBadge = new THREE.Mesh(geo, makeBadgeMaterials(spotifyTex));
      appleBadge   = new THREE.Mesh(geo, makeBadgeMaterials(appleTex));

      spotifyBadge.castShadow = appleBadge.castShadow = false;
      spotifyBadge.receiveShadow = appleBadge.receiveShadow = false;

      badgeGroup.add(spotifyBadge);
      badgeGroup.add(appleBadge);

      badgesReady = true;
      updateBadgesTransform();
      badgeGroup.visible = badgesActivated;
    }

    function updateBadgesTransform(){
      if (!badgesReady || !vaseReady) return;
      const center = new THREE.Vector3();
      vaseGroup.getWorldPosition(center);

      const base = Math.min(ROOM_W, ROOM_H) * 0.12 * badgesConfig.sizeMul;
      const depth = base * 0.3 * badgesConfig.thicknessMul;
      const height = base * 0.6 * badgesConfig.heightMul;

      const xOffsetBase = Math.min(ROOM_W, ROOM_D) * 0.4 * badgesConfig.offsetXMul;
      const yOffsetBase = Math.min(ROOM_H, ROOM_D) * 0.15 * badgesConfig.heightMul;
      const zBase = center.z + badgesConfig.zOffset;

      if (spotifyBadge){
        spotifyBadge.scale.set(base, height, depth);
        spotifyBadge.position.set(center.x - xOffsetBase, center.y + yOffsetBase, zBase);
      }
      if (appleBadge){
        appleBadge.scale.set(base, height, depth);
        appleBadge.position.set(center.x + xOffsetBase, center.y + yOffsetBase, zBase);
      }
    }

    buildBadges();

    // Badge click -> links
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    function onPointerClick(e){
      const rect = renderer.domElement.getBoundingClientRect();
      const x = ( (e.clientX - rect.left) / rect.width ) * 2 - 1;
      const y = - ( (e.clientY - rect.top) / rect.height ) * 2 + 1;
      pointer.set(x, y);
      raycaster.setFromCamera(pointer, camera);
      const targets = [];
      if (spotifyBadge) targets.push(spotifyBadge);
      if (appleBadge) targets.push(appleBadge);
      const hits = raycaster.intersectObjects(targets, false);
      if (!hits.length) return;
      const obj = hits[0].object;
      if (obj === spotifyBadge){
        window.open('https://open.spotify.com/', '_blank', 'noopener');
      } else if (obj === appleBadge){
        window.open('https://music.apple.com/', '_blank', 'noopener');
      }
    }
    window.addEventListener('click', onPointerClick, {passive:true});

    /* -------------------- resize & layout -------------------- */
    function updateLayout(){
      renderer.setSize(vw(), vh(), false);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, isPhone() ? 1.5 : 1.8));
      renderer.toneMappingExposure = CONFIG.lights.exposure;
      key.position.set(1.5, -ROOM_H*0.1, room.position.z + ROOM_D*0.05);
      resizePost();
      applyVaseScale();
      resizeWater();
      adjustRoomToViewport();
      updateBadgesTransform();
    }
    window.addEventListener('resize', updateLayout, {passive:true});
    window.addEventListener('orientationchange', updateLayout, {passive:true});
    if (window.visualViewport) window.visualViewport.addEventListener('resize', updateLayout, {passive:true});
    window.addEventListener('touchmove', e=>e.preventDefault(), {passive:false});
    window.addEventListener('wheel',     e=>e.preventDefault(), {passive:false});

    setupInputMode();
    updateLayout();

    /* -------------------- audio: idle -> full, tied to spin -------------------- */
    const AUDIO_URL = "./soundtrackComp.mp3";
    const AUDIO_IDLE_RATE = 0.25;
    const AUDIO_IDLE_LPF  = 380;
    const AUDIO_NORMAL_RATE = 1.0;
    const AUDIO_NORMAL_LPF  = 18000;
    const AUDIO_SMOOTH = 0.18;

    let audioCtx = null;
    let audioBuffer = null;
    let sourceNode = null;
    let filterNode = null;
    let gainNode = null;
    let audioReady = false;
    let audioStarted = false;

    async function loadAudioBuffer(ctx){
      if (audioBuffer) return audioBuffer;
      const res = await fetch(AUDIO_URL);
      const arr = await res.arrayBuffer();
      audioBuffer = await ctx.decodeAudioData(arr);
      return audioBuffer;
    }

    function buildGraph(ctx){
      filterNode = ctx.createBiquadFilter();
      filterNode.type = 'lowpass';
      filterNode.frequency.value = AUDIO_IDLE_LPF;
      filterNode.Q.value = 0.0001;

      gainNode = ctx.createGain();
      gainNode.gain.value = 0.9;

      filterNode.connect(gainNode).connect(ctx.destination);
    }

    function startLoopingSource(ctx){
      if (!audioBuffer) return;
      stopSource();
      sourceNode = ctx.createBufferSource();
      sourceNode.buffer = audioBuffer;
      sourceNode.loop = true;
      sourceNode.playbackRate.value = AUDIO_IDLE_RATE;
      sourceNode.connect(filterNode);
      const t = ctx.currentTime;
      sourceNode.start(t + 0.01);
      audioStarted = true;
    }

    function stopSource(){
      if (sourceNode){
        try { sourceNode.stop(); } catch(_) {}
        try { sourceNode.disconnect(); } catch(_) {}
        sourceNode = null;
      }
    }

    async function initAudio(forceResume=false){
      if (!audioCtx){
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        buildGraph(audioCtx);
      }
      if (audioCtx.state === 'suspended' && forceResume){
        try { await audioCtx.resume(); } catch(e){ /* ignore */ }
      }
      if (!audioBuffer){
        try { await loadAudioBuffer(audioCtx); } catch(e){ console.warn('Audio load failed:', e); return; }
      }
      if (!audioStarted){
        startLoopingSource(audioCtx);
        setIdleAudioTargets();
      }
      audioReady = true;
    }

    async function maybeStartAudio(force=false){
      if (!audioReady || (audioCtx && audioCtx.state==='suspended') || !audioStarted){
        await initAudio(force);
      }
    }

    function easeCubic(t){ return t*t*(3 - 2*t); }

    function setIdleAudioTargets(){
      if (!audioCtx || !filterNode || !sourceNode) return;
      const t = audioCtx.currentTime + 0.01;
      filterNode.frequency.cancelScheduledValues(t);
      filterNode.frequency.setTargetAtTime(AUDIO_IDLE_LPF, t, AUDIO_SMOOTH);
      sourceNode.playbackRate.cancelScheduledValues(t);
      sourceNode.playbackRate.setTargetAtTime(AUDIO_IDLE_RATE, t, AUDIO_SMOOTH);
    }

    function updateAudioBySpeed(speedAbs){
      if (!audioReady || !sourceNode || !filterNode) return;
      const k = easeCubic(THREE.MathUtils.clamp(speedAbs / Math.max(0.001, FULL_SPIN_SPEED), 0, 1));
      const rate = THREE.MathUtils.lerp(AUDIO_IDLE_RATE, AUDIO_NORMAL_RATE, k);
      const lpf  = THREE.MathUtils.lerp(AUDIO_IDLE_LPF,  AUDIO_NORMAL_LPF,  k);
      const t = audioCtx.currentTime + 0.01;
      sourceNode.playbackRate.cancelScheduledValues(t);
      sourceNode.playbackRate.setTargetAtTime(rate, t, AUDIO_SMOOTH);
      filterNode.frequency.cancelScheduledValues(t);
      filterNode.frequency.setTargetAtTime(lpf, t, AUDIO_SMOOTH);
    }

    window.addEventListener('load', ()=> { initAudio(false); }, {once:true});
    window.addEventListener('pointerdown', ()=> { maybeStartAudio(true); }, {once:true});

    /* -------------------- header opacity from spin -------------------- */
    function updateHeaderOpacityWithSpeed(speedAbs){
      if (!headerMat) return;
      if (headerOpacityLocked) return;
      const t = THREE.MathUtils.clamp(speedAbs / Math.max(0.001, FULL_SPIN_SPEED), 0, 1);
      const k = t*t*(3 - 2*t); // smooth
      const expOpacity = HEADER_OPACITY_MAX * (1.0 - Math.exp(-4.0 * k));
      headerMat.opacity = expOpacity;
      if (k >= 0.999){
        headerMat.opacity = HEADER_OPACITY_MAX;
        headerOpacityLocked = true;
      }
    }

    /* -------------------- main loop -------------------- */
    const clock = new THREE.Clock();
    const tmpV3 = new THREE.Vector3();

    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.033);
      const timeSec = clock.elapsedTime;

      updateVase(dt, timeSec);

      const speedAbs = Math.abs(angVel);

      // wall shader reacts to spin
      if (wallShaderRef){
        const dir = (angVel >= 0 ? 1.0 : -1.0);
        const speedFactor = 1.0 + Math.min(3.0, speedAbs * 2.4);
        wallShaderRef.uniforms.uTime.value += dt * dir * speedFactor;
      }

      // badges: appear once at full speed
      if (!badgesActivated && speedAbs >= FULL_SPIN_SPEED){
        badgesActivated = true;
        if (badgesReady) badgeGroup.visible = true;
      }

      // audio + header from speed
      updateAudioBySpeed(speedAbs);
      updateHeaderOpacityWithSpeed(speedAbs);

      // env map every frame so header/vase have light from start
      cubeCam.position.copy(vaseGroup.getWorldPosition(tmpV3));
      if (vaseReady && vase) vase.visible = false;
      cubeCam.update(renderer, scene);
      if (vaseReady && vase) vase.visible = true;

      // room tilt
      room.rotation.x += (targetRX - room.rotation.x) * 0.06;
      room.rotation.y += (targetRY - room.rotation.y) * 0.06;
      edges.rotation.copy(room.rotation);

      // header simply faces camera
      if (headerMesh){
        headerGroup.lookAt(camera.position);
      }

      // water uniforms
      updateWaterCenterFromVase();
      waterUniforms.uTime.value = timeSec;
      waterUniforms.uSpinAbs.value = speedAbs;

      // badges follow vase
      updateBadgesTransform();

      const usePost = (CONFIG.post.pixelSize > 1) || (CONFIG.post.ditherStrength > 0.0001);
      if (usePost){
        renderer.setRenderTarget(rt);
        renderer.render(scene, camera);
        renderer.setRenderTarget(null);
        renderer.render(screenScene, screenCam);
      } else {
        renderer.render(scene, camera);
      }
    }
    animate();

    /* -------------------- tabs & UI -------------------- */
    const panel = document.getElementById('panel');
    document.getElementById('tabs').addEventListener('click', (e)=>{
      const btn = e.target.closest('.tab-btn'); if(!btn) return;
      for (const b of e.currentTarget.querySelectorAll('.tab-btn')) b.classList.toggle('active', b===btn);
      for (const page of document.querySelectorAll('.tabpage')) page.classList.toggle('active', page.id === btn.dataset.tab);
    });

    const toggleBtn = document.getElementById('toggleControls');
    function togglePanel(){ panel.style.display = (panel.style.display === 'block') ? 'none' : 'block'; }
    toggleBtn.addEventListener('click', togglePanel);
    window.addEventListener('keydown', (e)=>{ if (e.key.toLowerCase() === 'h') togglePanel(); });

    const $ = id => document.getElementById(id);
    function setVal(id, val){ const el=$(id); if(el){ el.value=val; } }

    function bindRange(numId, rangeId, getVal, setValFn){
      const num=$(numId), range=$(rangeId);
      const init = getVal();
      num.value = init;
      range.value = init;
      const sync=(v)=>{
        const val = +v;
        num.value=val;
        range.value=val;
        setValFn(val);
      };
      num.addEventListener('change', e=>sync(e.target.value));
      range.addEventListener('input', e=>sync(e.target.value));
    }

    function syncVasePositionInputs(){
      $('vaseZ').value = $('vaseZNum').value = vaseGroup.position.z;
      $('vaseYPos').value = $('vaseYPosNum').value = vaseGroup.position.y;
    }

    // Vase
    bindRange('vaseNum','vase', ()=>CONFIG.vase.userScaleMult, v=>{
      CONFIG.vase.userScaleMult = Math.max(0.05, v);
      userScaleMult = CONFIG.vase.userScaleMult;
      applyVaseScale();
    });
    bindRange('vaseYNum','vaseY', ()=>CONFIG.vase.userTallY, v=>{
      CONFIG.vase.userTallY = Math.max(0.05, v);
      userTallY = CONFIG.vase.userTallY;
      applyVaseScale();
    });
    bindRange('vaseZNum','vaseZ', ()=>CONFIG.vase.z, v=>{
      CONFIG.vase.z=v;
      vaseGroup.position.z=v;
      updateBadgesTransform();
    });
    bindRange('vaseYPosNum','vaseYPos', ()=>CONFIG.vase.y, v=>{
      CONFIG.vase.y=v;
      vaseGroup.position.y=v;
      updateBadgesTransform();
    });

    // Spin
    bindRange('dampNum','damp', ()=>CONFIG.spin.damping, v=>{
      CONFIG.spin.damping=v;
      DAMPING=v;
    });
    bindRange('minNum','min', ()=>CONFIG.spin.minSpin, v=>{
      CONFIG.spin.minSpin=v;
      MIN_SPIN=v;
    });
    bindRange('impNum','imp', ()=>CONFIG.spin.swipeImpulse, v=>{
      CONFIG.spin.swipeImpulse=v;
      IMPULSE_SCALE=v;
    });

    // Room depth & Z
    bindRange('dNum','d', ()=>ROOM_D, v=>{
      ROOM_D=v;
      adjustRoomToViewport();
    });
    bindRange('zNum','z', ()=>room.position.z, v=>{
      room.position.z=v;
      edges.position.copy(room.position);
      adjustRoomToViewport();
    });

    // Wall image
    bindRange('zoomNum','zoom', ()=>CONFIG.room.imageZoom, v=>{
      CONFIG.room.imageZoom=v;
      applyTextureZoom(tex, v);
    });
    bindRange('edgeNum','edge', ()=>edges.material.opacity, v=>{
      edges.material.opacity = Math.max(0, Math.min(1, v));
      edges.material.needsUpdate=true;
    });

    // Lights
    bindRange('expNum','exp', ()=>CONFIG.lights.exposure, v=>{
      CONFIG.lights.exposure=v;
      renderer.toneMappingExposure=v;
    });
    bindRange('ambNum','amb', ()=>CONFIG.lights.ambient, v=>{
      CONFIG.lights.ambient=v;
      amb.intensity=v;
    });
    bindRange('hemNum','hem', ()=>CONFIG.lights.hemisphere, v=>{
      CONFIG.lights.hemisphere=v;
      hemi.intensity=v;
    });
    bindRange('rimNum','rim', ()=>CONFIG.lights.rim, v=>{
      CONFIG.lights.rim=v;
      rim.intensity=v;
    });
    bindRange('keyNum','key', ()=>CONFIG.lights.key, v=>{
      CONFIG.lights.key=v;
      key.intensity=v;
    });
    bindRange('vlINum','vlI', ()=>CONFIG.lights.vaseLight.intensity, v=>{
      CONFIG.lights.vaseLight.intensity=v;
      vaseLight.intensity=v;
    });
    bindRange('vlDNum','vlD', ()=>CONFIG.lights.vaseLight.distance, v=>{
      CONFIG.lights.vaseLight.distance=v;
      vaseLight.distance=v;
    });
    bindRange('vlDecNum','vlDec', ()=>CONFIG.lights.vaseLight.decay, v=>{
      CONFIG.lights.vaseLight.decay=v;
      vaseLight.decay=v;
    });
    bindRange('vlYNum','vlY', ()=>CONFIG.lights.vaseLight.y, v=>{
      CONFIG.lights.vaseLight.y=v;
      vaseLight.position.y=v;
    });

    // Room FX
    bindRange('emisNum','emis', ()=>CONFIG.room.wallEmissive, v=>{
      CONFIG.room.wallEmissive=v;
      wallMat.emissiveIntensity=v;
      wallMat.needsUpdate=true;
    });
    bindRange('dispNum','disp', ()=>CONFIG.room.wallDispAmp, v=>{
      CONFIG.room.wallDispAmp=v;
      if(wallShaderRef) wallShaderRef.uniforms.uDispAmp.value=v;
    });
    bindRange('dsNum','ds', ()=>CONFIG.room.wallDispSpeed, v=>{
      CONFIG.room.wallDispSpeed=v;
      if(wallShaderRef) wallShaderRef.uniforms.uDispSpeed.value=v;
    });

    // Water
    bindRange('wAmpNum','wAmp', ()=>CONFIG.water.amp, v=>{
      CONFIG.water.amp=v;
      waterUniforms.uAmp.value=v;
    });
    bindRange('wFreqNum','wFreq', ()=>CONFIG.water.freq, v=>{
      CONFIG.water.freq=v;
      waterUniforms.uFreq.value=v;
    });
    bindRange('wSpeedNum','wSpeed', ()=>CONFIG.water.speed, v=>{
      CONFIG.water.speed=v;
      waterUniforms.uSpeed.value=v;
    });
    bindRange('wFallNum','wFall', ()=>CONFIG.water.falloff, v=>{
      CONFIG.water.falloff=v;
      waterUniforms.uFalloff.value=v;
    });
    bindRange('wAlphaNum','wAlpha', ()=>CONFIG.water.alpha, v=>{
      CONFIG.water.alpha=v;
      waterUniforms.uAlpha.value=v;
    });
    bindRange('wRadNum','wRad', ()=>CONFIG.water.radius, v=>{
      CONFIG.water.radius=v;
      waterUniforms.uRadius.value=v;
    });
    bindRange('wPixNum','wPix', ()=>CONFIG.water.pixel, v=>{
      CONFIG.water.pixel=v|0;
      waterUniforms.uPixel.value=v|0;
    });
    bindRange('wYNum','wY', ()=>CONFIG.water.yOffset, v=>{
      CONFIG.water.yOffset=v;
      resizeWater();
    });

    $('wR').value = CONFIG.water.tint[0];
    $('wG').value = CONFIG.water.tint[1];
    $('wB').value = CONFIG.water.tint[2];
    const setWTint=()=>{
      waterUniforms.uColor.value.setRGB(+$('wR').value, +$('wG').value, +$('wB').value);
    };
    $('wR').addEventListener('change', setWTint);
    $('wG').addEventListener('change', setWTint);
    $('wB').addEventListener('change', setWTint);
    setWTint();

    // Global FX
    bindRange('pixNum','pix', ()=>CONFIG.post.pixelSize, v=>{
      CONFIG.post.pixelSize = v|0;
      fsMat.uniforms.pixelSize.value = Math.max(1, v|0);
    });
    bindRange('dithNum','dith', ()=>CONFIG.post.ditherStrength, v=>{
      CONFIG.post.ditherStrength = Math.max(0, v);
      fsMat.uniforms.ditherStrength.value = CONFIG.post.ditherStrength;
    });

    // Vase FX
    bindRange('glassTransNum','glassTrans', ()=>CONFIG.glass.transmission, v=>{
      CONFIG.glass.transmission=v;
      applyGlassConfigToMaterials();
    });
    bindRange('glassThickNum','glassThick', ()=>CONFIG.glass.thickness, v=>{
      CONFIG.glass.thickness=v;
      applyGlassConfigToMaterials();
    });
    bindRange('glassIorNum','glassIor', ()=>CONFIG.glass.ior, v=>{
      CONFIG.glass.ior=v;
      applyGlassConfigToMaterials();
    });
    bindRange('glassRoughNum','glassRough', ()=>CONFIG.glass.roughness, v=>{
      CONFIG.glass.roughness=v;
      applyGlassConfigToMaterials();
    });
    bindRange('glassCCNum','glassCC', ()=>CONFIG.glass.clearcoat, v=>{
      CONFIG.glass.clearcoat=v;
      applyGlassConfigToMaterials();
    });
    bindRange('glassCCRNum','glassCCR', ()=>CONFIG.glass.ccRough, v=>{
      CONFIG.glass.ccRough=v;
      applyGlassConfigToMaterials();
    });
    bindRange('glassEnvNum','glassEnv', ()=>CONFIG.glass.envIntensity, v=>{
      CONFIG.glass.envIntensity=v;
      applyGlassConfigToMaterials();
    });
    bindRange('glassMetalNum','glassMetal', ()=>CONFIG.glass.metalness, v=>{
      CONFIG.glass.metalness=Math.max(0, Math.min(1, v));
      applyGlassConfigToMaterials();
    });

    $('glassColR').value = CONFIG.glass.color[0];
    $('glassColG').value = CONFIG.glass.color[1];
    $('glassColB').value = CONFIG.glass.color[2];
    function setGlassBaseColor(){
      CONFIG.glass.color[0] = THREE.MathUtils.clamp(+$('glassColR').value, 0, 1);
      CONFIG.glass.color[1] = THREE.MathUtils.clamp(+$('glassColG').value, 0, 1);
      CONFIG.glass.color[2] = THREE.MathUtils.clamp(+$('glassColB').value, 0, 1);
      applyGlassConfigToMaterials();
    }
    $('glassColR').addEventListener('change', setGlassBaseColor);
    $('glassColG').addEventListener('change', setGlassBaseColor);
    $('glassColB').addEventListener('change', setGlassBaseColor);

    $('glassAttR').value = CONFIG.glass.attnColor[0];
    $('glassAttG').value = CONFIG.glass.attnColor[1];
    $('glassAttB').value = CONFIG.glass.attnColor[2];
    function setGlassAttnColor(){
      CONFIG.glass.attnColor[0] = THREE.MathUtils.clamp(+$('glassAttR').value, 0, 1);
      CONFIG.glass.attnColor[1] = THREE.MathUtils.clamp(+$('glassAttG').value, 0, 1);
      CONFIG.glass.attnColor[2] = THREE.MathUtils.clamp(+$('glassAttB').value, 0, 1);
      applyGlassConfigToMaterials();
    }
    $('glassAttR').addEventListener('change', setGlassAttnColor);
    $('glassAttG').addEventListener('change', setGlassAttnColor);
    $('glassAttB').addEventListener('change', setGlassAttnColor);

    /* ----- header + badges UI ----- */
    function bindHeaderUI(){
      bindRange('hdrSizeNum','hdrSize', ()=>headerConfig.sizeMul, v=>{
        headerConfig.sizeMul = Math.max(0.2, Math.min(3, v));
        rebuildHeaderGeometry();
      });
      bindRange('hdrXNum','hdrX', ()=>headerConfig.x, v=>{
        headerConfig.x = v;
        applyHeaderTransform();
      });
      bindRange('hdrYNum','hdrY', ()=>headerConfig.y, v=>{
        headerConfig.y = v;
        applyHeaderTransform();
      });
      bindRange('hdrZNum','hdrZ', ()=>headerConfig.z, v=>{
        headerConfig.z = v;
        applyHeaderTransform();
      });

      bindRange('hdrMetalNum','hdrMetal', ()=>headerConfig.metalness, v=>{
        headerConfig.metalness = THREE.MathUtils.clamp(v,0,1);
        if (headerMat){ headerMat.metalness = headerConfig.metalness; headerMat.needsUpdate=true; }
      });
      bindRange('hdrRoughNum','hdrRough', ()=>headerConfig.roughness, v=>{
        headerConfig.roughness = THREE.MathUtils.clamp(v,0,1);
        if (headerMat){ headerMat.roughness = headerConfig.roughness; headerMat.needsUpdate=true; }
      });
      bindRange('hdrCCNum','hdrCC', ()=>headerConfig.clearcoat, v=>{
        headerConfig.clearcoat = THREE.MathUtils.clamp(v,0,1);
        if (headerMat){ headerMat.clearcoat = headerConfig.clearcoat; headerMat.needsUpdate=true; }
      });
      bindRange('hdrCCRNum','hdrCCR', ()=>headerConfig.clearcoatRoughness, v=>{
        headerConfig.clearcoatRoughness = THREE.MathUtils.clamp(v,0,1);
        if (headerMat){ headerMat.clearcoatRoughness = headerConfig.clearcoatRoughness; headerMat.needsUpdate=true; }
      });
      bindRange('hdrEnvNum','hdrEnv', ()=>headerConfig.envIntensity, v=>{
        headerConfig.envIntensity = Math.max(0,v);
        if (headerMat){ headerMat.envMapIntensity = headerConfig.envIntensity; headerMat.needsUpdate=true; }
      });
      bindRange('hdrTransNum','hdrTrans', ()=>headerConfig.transmission, v=>{
        headerConfig.transmission = THREE.MathUtils.clamp(v,0,1);
        if (headerMat){ headerMat.transmission = headerConfig.transmission; headerMat.needsUpdate=true; }
      });
      bindRange('hdrThickNum','hdrThick', ()=>headerConfig.thickness, v=>{
        headerConfig.thickness = Math.max(0.2, Math.min(3, v));
        if (headerMat){ headerMat.thickness = headerConfig.thickness; headerMat.needsUpdate=true; }
        rebuildHeaderGeometry();
      });
      bindRange('hdrEmissNum','hdrEmiss', ()=>headerConfig.emissiveIntensity, v=>{
        headerConfig.emissiveIntensity = Math.max(0, v);
        if (headerMat){ headerMat.emissiveIntensity = headerConfig.emissiveIntensity; headerMat.needsUpdate=true; }
      });

      // Badges
      bindRange('bdgSizeNum','bdgSize', ()=>badgesConfig.sizeMul, v=>{
        badgesConfig.sizeMul = Math.max(0.3, Math.min(3, v));
        updateBadgesTransform();
      });
      bindRange('bdgThickNum','bdgThick', ()=>badgesConfig.thicknessMul, v=>{
        badgesConfig.thicknessMul = Math.max(0.5, Math.min(4, v));
        updateBadgesTransform();
      });
      bindRange('bdgXOffNum','bdgXOff', ()=>badgesConfig.offsetXMul, v=>{
        badgesConfig.offsetXMul = Math.max(0, Math.min(2, v));
        updateBadgesTransform();
      });
      bindRange('bdgHeightNum','bdgHeight', ()=>badgesConfig.heightMul, v=>{
        badgesConfig.heightMul = Math.max(0, Math.min(4, v));
        updateBadgesTransform();
      });
      bindRange('bdgZOffNum','bdgZOff', ()=>badgesConfig.zOffset, v=>{
        badgesConfig.zOffset = v;
        updateBadgesTransform();
      });
    }

    function initHeaderUIValues(){
      setVal('hdrSize', headerConfig.sizeMul); setVal('hdrSizeNum', headerConfig.sizeMul);
      setVal('hdrX', headerConfig.x); setVal('hdrXNum', headerConfig.x);
      setVal('hdrY', headerConfig.y); setVal('hdrYNum', headerConfig.y);
      setVal('hdrZ', headerConfig.z); setVal('hdrZNum', headerConfig.z);

      setVal('hdrMetal', headerConfig.metalness); setVal('hdrMetalNum', headerConfig.metalness);
      setVal('hdrRough', headerConfig.roughness); setVal('hdrRoughNum', headerConfig.roughness);
      setVal('hdrCC', headerConfig.clearcoat); setVal('hdrCCNum', headerConfig.clearcoat);
      setVal('hdrCCR', headerConfig.clearcoatRoughness); setVal('hdrCCRNum', headerConfig.clearcoatRoughness);
      setVal('hdrEnv', headerConfig.envIntensity); setVal('hdrEnvNum', headerConfig.envIntensity);
      setVal('hdrTrans', headerConfig.transmission); setVal('hdrTransNum', headerConfig.transmission);
      setVal('hdrThick', headerConfig.thickness); setVal('hdrThickNum', headerConfig.thickness);
      setVal('hdrEmiss', headerConfig.emissiveIntensity); setVal('hdrEmissNum', headerConfig.emissiveIntensity);

      setVal('bdgSize', badgesConfig.sizeMul); setVal('bdgSizeNum', badgesConfig.sizeMul);
      setVal('bdgThick', badgesConfig.thicknessMul); setVal('bdgThickNum', badgesConfig.thicknessMul);
      setVal('bdgXOff', badgesConfig.offsetXMul); setVal('bdgXOffNum', badgesConfig.offsetXMul);
      setVal('bdgHeight', badgesConfig.heightMul); setVal('bdgHeightNum', badgesConfig.heightMul);
      setVal('bdgZOff', badgesConfig.zOffset); setVal('bdgZOffNum', badgesConfig.zOffset);
    }

    bindHeaderUI();

    /* ----- init values in UI ----- */
    function initUIValues(){
      setVal('vase', CONFIG.vase.userScaleMult); setVal('vaseNum', CONFIG.vase.userScaleMult);
      setVal('vaseY', CONFIG.vase.userTallY); setVal('vaseYNum', CONFIG.vase.userTallY);
      setVal('vaseZ', CONFIG.vase.z); setVal('vaseZNum', CONFIG.vase.z);
      setVal('vaseYPos', CONFIG.vase.y); setVal('vaseYPosNum', CONFIG.vase.y);

      setVal('damp', CONFIG.spin.damping); setVal('dampNum', CONFIG.spin.damping);
      setVal('min', CONFIG.spin.minSpin); setVal('minNum', CONFIG.spin.minSpin);
      setVal('imp', CONFIG.spin.swipeImpulse); setVal('impNum', CONFIG.spin.swipeImpulse);

      setVal('d', ROOM_D); setVal('dNum', ROOM_D);
      setVal('z', room.position.z); setVal('zNum', room.position.z);

      setVal('zoom', CONFIG.room.imageZoom); setVal('zoomNum', CONFIG.room.imageZoom);
      setVal('edge', edges.material.opacity); setVal('edgeNum', edges.material.opacity);

      setVal('exp', CONFIG.lights.exposure); setVal('expNum', CONFIG.lights.exposure);
      setVal('amb', CONFIG.lights.ambient); setVal('ambNum', CONFIG.lights.ambient);
      setVal('hem', CONFIG.lights.hemisphere); setVal('hemNum', CONFIG.lights.hemisphere);
      setVal('rim', CONFIG.lights.rim); setVal('rimNum', CONFIG.lights.rim);
      setVal('key', CONFIG.lights.key); setVal('keyNum', CONFIG.lights.key);
      setVal('vlI', CONFIG.lights.vaseLight.intensity); setVal('vlINum', CONFIG.lights.vaseLight.intensity);
      setVal('vlD', CONFIG.lights.vaseLight.distance); setVal('vlDNum', CONFIG.lights.vaseLight.distance);
      setVal('vlDec', CONFIG.lights.vaseLight.decay); setVal('vlDecNum', CONFIG.lights.vaseLight.decay);
      setVal('vlY', CONFIG.lights.vaseLight.y); setVal('vlYNum', CONFIG.lights.vaseLight.y);

      setVal('emis', CONFIG.room.wallEmissive); setVal('emisNum', CONFIG.room.wallEmissive);
      setVal('disp', CONFIG.room.wallDispAmp); setVal('dispNum', CONFIG.room.wallDispAmp);
      setVal('ds', CONFIG.room.wallDispSpeed); setVal('dsNum', CONFIG.room.wallDispSpeed);

      setVal('wAmp', CONFIG.water.amp); setVal('wAmpNum', CONFIG.water.amp);
      setVal('wFreq', CONFIG.water.freq); setVal('wFreqNum', CONFIG.water.freq);
      setVal('wSpeed', CONFIG.water.speed); setVal('wSpeedNum', CONFIG.water.speed);
      setVal('wFall', CONFIG.water.falloff); setVal('wFallNum', CONFIG.water.falloff);
      setVal('wAlpha', CONFIG.water.alpha); setVal('wAlphaNum', CONFIG.water.alpha);
      setVal('wRad', CONFIG.water.radius); setVal('wRadNum', CONFIG.water.radius);
      setVal('wPix', CONFIG.water.pixel); setVal('wPixNum', CONFIG.water.pixel);
      setVal('wY', CONFIG.water.yOffset); setVal('wYNum', CONFIG.water.yOffset);

      setVal('pix', CONFIG.post.pixelSize); setVal('pixNum', CONFIG.post.pixelSize);
      setVal('dith', CONFIG.post.ditherStrength); setVal('dithNum', CONFIG.post.ditherStrength);

      initHeaderUIValues();
    }
    initUIValues();

    // motion hint
    (function initMotionButton(){
      if (isPortrait() && (presetChoice==='phone') && window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function'){
        $('enableMotion').style.display = 'block';
      }
    })();

    /* ----- snapshot / copy controls ----- */
    function snapshotConfig(){
      const snap = structuredClone(CONFIG);
      snap.room.width = ROOM_W;
      snap.room.height = ROOM_H;
      snap.room.depth = ROOM_D;
      snap.room.positionZ = room.position.z;
      snap.vase.z = vaseGroup.position.z;
      snap.vase.y = vaseGroup.position.y;
      snap.post.pixelSize = fsMat.uniforms.pixelSize.value;
      snap.post.ditherStrength = fsMat.uniforms.ditherStrength.value;
      snap._internal = { WATER_RADIUS_FACTOR, TILT_MARGIN };
      snap._preset = presetChoice;

      snap.header = {
        opacity: headerMat ? headerMat.opacity : 0,
        sizeMul: headerConfig.sizeMul,
        x: headerConfig.x, y: headerConfig.y, z: headerConfig.z,
        locked: headerOpacityLocked,
        metalness: headerConfig.metalness,
        roughness: headerConfig.roughness,
        clearcoat: headerConfig.clearcoat,
        clearcoatRoughness: headerConfig.clearcoatRoughness,
        envIntensity: headerConfig.envIntensity,
        transmission: headerConfig.transmission,
        thickness: headerConfig.thickness,
        emissiveIntensity: headerConfig.emissiveIntensity
      };

      snap.badges = {
        sizeMul: badgesConfig.sizeMul,
        thicknessMul: badgesConfig.thicknessMul,
        offsetXMul: badgesConfig.offsetXMul,
        heightMul: badgesConfig.heightMul,
        zOffset: badgesConfig.zOffset,
        activated: badgesActivated
      };

      return snap;
    }
    function printControls(){ console.log(JSON.stringify(snapshotConfig(), null, 2)); }
    async function copyControls(){
      const text = JSON.stringify(snapshotConfig(), null, 2);
      try {
        await navigator.clipboard.writeText(text);
        console.log('Controls copied to clipboard.');
      } catch(e){
        console.warn('Clipboard copy failed:', e);
      }
    }
    window.printControls = printControls;
    window.copyControls  = copyControls;
    $('printControlsBtn').onclick = printControls;
    $('copyControlsBtn').onclick  = copyControls;

  </script>
</body>
</html>
