<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
  <title>Mysterious Room ‚Äî Album Promo (desktop+phone presets)</title>
  <style>
    /* Full-bleed viewport; lock scrolling */
    html, body { height: 100dvh; width: 100vw; }
    body {
      margin: 0; background: #000; overflow: hidden;
      overscroll-behavior: none; touch-action: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;
    }
    canvas { display: block; width: 100vw !important; height: 100dvh !important; }

    /* Control panel */
    .panel {
      position: fixed; top: 12px; left: 12px; z-index: 20;
      width: min(90vw, 380px);
      max-height: calc(100dvh - 24px);
      overflow: auto;
      padding: 12px; border-radius: 12px; backdrop-filter: blur(8px);
      background: #0b1020cc; border: 1px solid #88a7ff2a; color: #eaf0ff;
      box-shadow: 0 8px 28px #000a; font-size: 12px; letter-spacing: .02em;
      scrollbar-gutter: stable both-edges;
    }
    .panel h2 { margin: 0 0 8px; font-size: 13px; color:#cfe0ff; }
    details { border: 1px solid #5c75b42a; border-radius: 10px; padding: 6px 8px; margin: 8px 0; background:#0f1a38a6; }
    details[open] { background:#0f1a38d0; }
    summary { cursor: pointer; font-weight: 700; color:#cfe0ff; outline: none; }
    .row { display: grid; grid-template-columns: 1fr 58px; gap: 8px; align-items: center; margin: 6px 0; }
    .row input[type="range"] { width: 100%; }
    .row input[type="number"] {
      width: 58px; background:#0d1a3a; color:#eaf0ff; border:1px solid #446;
      border-radius:6px; padding:4px 6px; font-size:12px;
    }
    .two { display:flex; gap:8px; margin-top:8px; }
    .two > button {
      flex:1 1 0; padding:8px 10px; border-radius:10px; border:1px solid #6aa2ff33;
      background:#0e1736; color:#d9e6ff; cursor:pointer;
    }

    /* Floating toggle button for the panel */
    #gear {
      position: fixed; right: 12px; bottom: 12px; z-index: 21;
      width: 44px; height: 44px; border-radius: 50%;
      border: 1px solid #6aa2ff55; background:#0e1736; color:#dce8ff;
      display: grid; place-items: center; font-size: 20px; cursor: pointer;
      box-shadow: 0 8px 24px #000a;
    }
    #enableMotion {
      position: fixed; inset: auto 16px 66px auto; z-index: 22;
      padding: 10px 14px; border-radius: 12px; border: 1px solid #6aa2ff33;
      background: #0b1020; color: #cfe0ff; font: 600 12px/1.2 system-ui;
      letter-spacing: .05em; box-shadow: 0 6px 20px #0007; display: none;
    }

    @media (max-width: 600px) {
      .panel { width: min(94vw, 420px); max-height: 70dvh; }
    }
  </style>
</head>
<body>

  <!-- Controls -->
  <div class="panel" id="panel">
    <h2>Room Controls</h2>

    <details open>
      <summary>Size</summary>
      <div class="row"><label>Width</label><input id="wNum" type="number" step="0.1"><input id="w" type="range" min="3" max="30" step="0.1"></div>
      <div class="row"><label>Height</label><input id="hNum" type="number" step="0.1"><input id="h" type="range" min="2" max="24" step="0.1"></div>
      <div class="row"><label>Depth</label><input id="dNum" type="number" step="0.1"><input id="d" type="range" min="2" max="40" step="0.1"></div>
    </details>

    <details>
      <summary>Framing</summary>
      <div class="row"><label>Room Z</label><input id="zNum" type="number" step="0.1"><input id="z" type="range" min="-40" max="5" step="0.1"></div>
      <div class="row"><label>Portrait Overscan</label><input id="ovNum" type="number" step="0.01"><input id="ov" type="range" min="1.10" max="1.60" step="0.01"></div>
      <div class="two">
        <button id="fitPortrait">Fit (Portrait)</button>
        <button id="fitDesktop">Fit (Desktop)</button>
      </div>
    </details>

    <details>
      <summary>Appearance</summary>
      <div class="row"><label>Image Zoom</label><input id="zoomNum" type="number" step="0.01"><input id="zoom" type="range" min="0.5" max="3.0" step="0.01"></div>
      <div class="row"><label>Border Opacity</label><input id="edgeNum" type="number" step="0.01"><input id="edge" type="range" min="0" max="1" step="0.01"></div>
      <div class="row"><label>Wall Emissive</label><input id="emisNum" type="number" step="0.01"><input id="emis" type="range" min="0" max="1" step="0.01"></div>
    </details>

    <details open>
      <summary>Lights / Brightness</summary>
      <div class="row"><label>Exposure</label><input id="expNum" type="number" step="0.01"><input id="exp" type="range" min="0.6" max="3.0" step="0.01"></div>
      <div class="row"><label>Ambient</label><input id="ambNum" type="number" step="0.01"><input id="amb" type="range" min="0" max="3.0" step="0.01"></div>
      <div class="row"><label>Hemisphere</label><input id="hemiNum" type="number" step="0.01"><input id="hemi" type="range" min="0" max="3.0" step="0.01"></div>
      <div class="row"><label>Rim Light</label><input id="rimNum" type="number" step="0.01"><input id="rim" type="range" min="0" max="4.0" step="0.01"></div>
      <div class="row"><label>Key Light</label><input id="keyINum" type="number" step="0.01"><input id="keyI" type="range" min="0" max="4.0" step="0.01"></div>
      <hr style="border:none;border-top:1px solid #5c75b42a; margin:8px 0;">
      <div class="row"><label>Vase Light Intensity</label><input id="vliNum" type="number" step="0.1"><input id="vli" type="range" min="0" max="12" step="0.1"></div>
      <div class="row"><label>Vase Light Distance</label><input id="vldNum" type="number" step="0.1"><input id="vld" type="range" min="1" max="30" step="0.1"></div>
      <div class="row"><label>Vase Light Decay</label><input id="vlcNum" type="number" step="0.1"><input id="vlc" type="range" min="0.1" max="4" step="0.1"></div>
      <div class="row"><label>Vase Light Y</label><input id="vlyNum" type="number" step="0.01"><input id="vly" type="range" min="-2" max="2" step="0.01"></div>
    </details>

    <details>
      <summary>Vase</summary>
      <div class="row"><label>Scale √ó</label><input id="vaseNum" type="number" step="0.01"><input id="vase" type="range" min="0.2" max="5.0" step="0.01"></div>
      <div class="row"><label>Tallness (Y)</label><input id="vaseYNum" type="number" step="0.01"><input id="vaseY" type="range" min="0.5" max="3.0" step="0.01"></div>
      <div class="row"><label>Pos Z</label><input id="vaseZNum" type="number" step="0.1"><input id="vaseZ" type="range" min="-40" max="10" step="0.1"></div>
      <div class="row"><label>Pos Y</label><input id="vaseYPosNum" type="number" step="0.1"><input id="vaseYPos" type="range" min="-10" max="10" step="0.1"></div>
    </details>

    <details>
      <summary>Spin</summary>
      <div class="row"><label>Damping</label><input id="dampNum" type="number" step="0.001"><input id="damp" type="range" min="0.90" max="0.999" step="0.001"></div>
      <div class="row"><label>Min Spin</label><input id="minNum" type="number" step="0.01"><input id="min" type="range" min="0.0" max="1.0" step="0.01"></div>
      <div class="row"><label>Swipe Impulse</label><input id="impNum" type="number" step="0.0001"><input id="imp" type="range" min="0.0005" max="0.02" step="0.0001"></div>
    </details>

    <details>
      <summary>FX ‚Äì Screen</summary>
      <div class="row"><label>Pixel Size</label><input id="pixNum" type="number" step="1"><input id="pix" type="range" min="1" max="24" step="1"></div>
      <div class="row"><label>Dither Strength</label><input id="dithNum" type="number" step="0.01"><input id="dith" type="range" min="0" max="1" step="0.01"></div>
    </details>

    <details>
      <summary>FX ‚Äì Walls</summary>
      <div class="row"><label>Disp Amplitude</label><input id="dispNum" type="number" step="0.001"><input id="disp" type="range" min="0" max="0.08" step="0.001"></div>
      <div class="row"><label>Disp Speed</label><input id="dsNum" type="number" step="0.01"><input id="ds" type="range" min="0" max="6" step="0.01"></div>
    </details>
  </div>

  <button id="gear" aria-label="Toggle controls">‚öôÔ∏è</button>
  <button id="enableMotion">Enable Motion</button>

  <!-- three.js -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    /* ---------- PRESETS ---------- */

    // Laptop/Desktop preset (your earlier defaults)
    const DEFAULT_PRESET_DESKTOP = {
      room: {
        width: 18.3, height: 13.3, depth: 24,
        positionZ: -4.7,
        portraitOverscan: 1.31,
        imageZoom: 0.9,
        borderOpacity: 0,
        wallEmissive: 0.35,
        wallDispAmp: 0.018,
        wallDispSpeed: 3.26
      },
      lights: {
        exposure: 0.86,
        ambient: 1.91,
        hemisphere: 2.0,
        rim: 1.87,
        key: 1.68,
        vaseLight: { intensity: 6, distance: 8.6, decay: 1.6, y: 0.08 }
      },
      vase: { userScaleMult: 2.62, userTallY: 1.35, z: -8, y: -2.2 },
      spin: { damping: 0.955, minSpin: 0.6, swipeImpulse: 0.01 },
      post: { pixelSize: 6, ditherStrength: 0.13 }
    };

    // Phone-only preset (your new values)
    const DEFAULT_PRESET_PHONE = {
      room: {
        width: 9.7, height: 11.8, depth: 20.5,
        positionZ: -5.1,
        portraitOverscan: 1.49,
        imageZoom: 1.03,
        borderOpacity: 0.02,
        wallEmissive: 0.35,
        wallDispAmp: 0.01,
        wallDispSpeed: 1.67
      },
      lights: {
        exposure: 2.04,
        ambient: 1.98,
        hemisphere: 1.98,
        rim: 2.55,
        key: 2.21,
        vaseLight: { intensity: 4.3, distance: 17.3, decay: 1.6, y: 0.08 }
      },
      vase: { userScaleMult: 1.46, userTallY: 2.09, z: -2.1, y: 1.3 },
      spin: { damping: 0.955, minSpin: 0.6, swipeImpulse: 0.01 },
      post: { pixelSize: 5, ditherStrength: 0.17 }
    };

    const vw = ()=> (window.visualViewport?.width  || window.innerWidth);
    const vh = ()=> (window.visualViewport?.height || window.innerHeight);
    const isPortrait = ()=> vh() >= vw();
    const isTouch = ()=> 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    const isPhoneLike = () => {
      const coarse = isTouch();
      const narrow = vw() <= 820;
      const uaMobile = navigator.userAgentData?.mobile ?? /Mobi|Android/i.test(navigator.userAgent);
      return coarse && (narrow || uaMobile);
    };

    // URL override for testing: ?preset=phone / ?preset=desktop
    function presetFromQuery() {
      const p = new URLSearchParams(location.search).get('preset');
      if (!p) return null;
      return p.toLowerCase() === 'phone' ? 'phone'
           : p.toLowerCase() === 'desktop' ? 'desktop'
           : null;
    }

    const PRESET_CHOICE = (presetFromQuery() ?? (isPhoneLike() ? 'phone' : 'desktop'));
    const START_PRESET = PRESET_CHOICE === 'phone' ? DEFAULT_PRESET_PHONE : DEFAULT_PRESET_DESKTOP;

    /* ---------- RENDERER / SCENE / CAMERA ---------- */
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.physicallyCorrectLights = true;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.8));
    renderer.setSize(vw(), vh(), false);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.25; // will be set by preset
    renderer.setClearColor(0x000000, 1);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0d1220, 18, 40);

    const camera = new THREE.PerspectiveCamera(55, vw()/vh(), 0.1, 100);
    camera.position.set(0, 0, 7.5);

    /* ---------- TEXTURE / WALLS ---------- */
    const textureURL = "/reilly-album-cvr.jpeg";
    const tLoader = new THREE.TextureLoader();
    tLoader.setCrossOrigin("anonymous");
    const tex = tLoader.load(textureURL, () => {
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      applyTextureZoom(tex, 1.0);
    });

    const wallMat = new THREE.MeshStandardMaterial({
      map: tex,
      side: THREE.BackSide,
      roughness: 0.8,
      metalness: 0.0,
      emissive: new THREE.Color(0x2a365c),
      emissiveIntensity: 0.30,
      envMapIntensity: 0.18
    });

    let wallShaderRef = null;
    wallMat.onBeforeCompile = (shader)=>{
      shader.fragmentShader = shader.fragmentShader.replace(
        '#include <common>',
        `#include <common>
         uniform float uTime;
         uniform float uDispAmp;
         uniform float uDispSpeed;`
      );
      shader.fragmentShader = shader.fragmentShader.replace(
        '#include <map_fragment>',
        `#ifdef USE_MAP
          vec2 uv2 = vMapUv;
          float g = 120.0;
          vec2 grid = floor(uv2 * g)/g;
          float t = uTime * uDispSpeed;
          vec2 warp = vec2(
            sin(grid.y*40.0 + t*2.2),
            cos(grid.x*40.0 - t*1.7)
          ) * uDispAmp;
          vec4 sampledDiffuseColor = texture2D( map, uv2 + warp );
          diffuseColor *= sampledDiffuseColor;
        #endif`
      );
      shader.uniforms.uTime      = { value: 0.0 };
      shader.uniforms.uDispAmp   = { value: 0.02 };
      shader.uniforms.uDispSpeed = { value: 1.5 };
      wallShaderRef = shader;
    };

    function applyTextureZoom(texture, z=1.0){
      const r = 1 / Math.max(z, 0.0001);
      texture.center.set(0.5, 0.5);
      texture.repeat.set(r, r);
      texture.offset.set((1 - r) * 0.5, (1 - r) * 0.5);
      texture.needsUpdate = true;
    }
    window.setImageZoom = z => applyTextureZoom(tex, z);

    /* ---------- ROOM GEOMETRY + UV ---------- */
    let ROOM_W = 12, ROOM_H = 7.2, ROOM_D = 10;
    function buildRoomGeometry(w, h, d){
      const geo = new THREE.BoxGeometry(w, h, d, 1, 1, 1);
      const tileW = 1/4, tileH = 1/3;
      const regions = { px:{u0:0.5,v0:1/3}, nx:{u0:0,v0:1/3}, py:{u0:0.25,v0:2/3}, ny:{u0:0.25,v0:0}, pz:{u0:0.25,v0:1/3}, nz:{u0:0.75,v0:1/3} };
      const uv = geo.getAttribute('uv'); const arr = uv.array; const stride = 12;
      const faces=[regions.px,regions.nx,regions.py,regions.ny,regions.pz,regions.nz];
      const put=(off,u0,v0,u1,v1,flipH)=>{
        let A=[u0,v0],B=[u1,v0],C=[u1,v1],D=[u0,v1];
        if (flipH){ [A,B,C,D]=[[B[0],B[1]],[A[0],A[1]],[D[0],D[1]],[C[0],C[1]]]; }
        const uvs=[A[0],A[1], B[0],B[1], D[0],D[1],  B[0],B[1], C[0],C[1], D[0],D[1]];
        for(let i=0;i<12;i++) arr[off+i]=uvs[i];
      };
      for(let f=0; f<6; f++){
        const r=faces[f], u0=r.u0, v0=r.v0, u1=u0+tileW, v1=v0+tileH;
        put(f*stride,u0,v0,u1,v1,true);
      }
      uv.needsUpdate = true; return geo;
    }

    const roomGeo = buildRoomGeometry(ROOM_W, ROOM_H, ROOM_D);
    const room = new THREE.Mesh(roomGeo, wallMat);
    room.position.set(0, 0, -ROOM_D * 0.5);
    scene.add(room);

    let edges = new THREE.LineSegments(
      new THREE.EdgesGeometry(roomGeo),
      new THREE.LineBasicMaterial({ color: 0xF0F6FF, transparent: true, opacity: 1.0 })
    );
    edges.position.copy(room.position);
    scene.add(edges);

    /* ---------- LIGHTS ---------- */
    const ambient = new THREE.AmbientLight(0xdde6ff, 0.25); scene.add(ambient);
    const hemi = new THREE.HemisphereLight(0x9fbfff, 0x202a44, 0.45); scene.add(hemi);
    const rim = new THREE.DirectionalLight(0xeef3ff, 1.0); rim.position.set(-1.4, 2.2, 1.6); scene.add(rim);
    const key = new THREE.PointLight(0xffffff, 0.75, 18, 2.0);
    key.position.set(1.5, -ROOM_H*0.1, room.position.z + ROOM_D*0.05); scene.add(key);

    /* ---------- ENVMAP + VASE ---------- */
    const cubeRT = new THREE.WebGLCubeRenderTarget(256, { generateMipmaps:true, minFilter:THREE.LinearMipmapLinearFilter, magFilter:THREE.LinearFilter });
    cubeRT.texture.colorSpace = THREE.SRGBColorSpace;
    const cubeCam = new THREE.CubeCamera(0.1, 100, cubeRT); scene.add(cubeCam);

    const vaseGroup = new THREE.Group(); scene.add(vaseGroup);
    let vase=null, vaseReady=false, vaseLight=null;

    const VASE_URL = "./spintop.glb";
    const gltf = new GLTFLoader();
    gltf.load(VASE_URL, g=>{
      vase = g.scene;
      const glassParams = {
        color: 0xffffff, metalness: 0.0, roughness: 0.03, transmission: 1.0, thickness: 1.2,
        ior: 1.52, clearcoat: 1.0, clearcoatRoughness: 0.04,
        attenuationColor: new THREE.Color(0xa8c9ff), attenuationDistance: 2.0,
        envMap: cubeRT.texture, envMapIntensity: 1.9
      };
      vase.traverse(n=>{ if(n.isMesh) n.material = new THREE.MeshPhysicalMaterial(glassParams); });
      vaseBaseScale = autoScaleToRoom(vase);
      userScaleMult = 1.2; userTallY = 1.3; applyVaseScale();
      vaseGroup.add(vase);
      placeOnFloor(vaseGroup);
      vaseGroup.position.z = room.position.z - ROOM_D * 0.30;

      // inner light
      vaseLight = new THREE.PointLight(0x88c6ff, 2.4, 7.0, 2.0);
      vaseLight.position.set(0, 0.38, 0);
      vaseGroup.add(vaseLight);
      const core = new THREE.Mesh(
        new THREE.IcosahedronGeometry(0.09, 1),
        new THREE.MeshPhysicalMaterial({
          color: 0xffffff, emissive: 0x66aaff, emissiveIntensity: 3.2,
          transmission: 0.5, thickness: 0.3, roughness: 0.2, metalness: 0.0, ior: 1.3
        })
      );
      vaseLight.add(core);

      vaseReady = true;
      syncVasePositionInputs();
      bindVaseLightUI();

      // Re-apply selected preset (so vase & inner light match)
      applyControls(START_PRESET);
      syncPanelFromLive();
    });

    function placeOnFloor(obj){
      obj.updateMatrixWorld(true);
      const bbox = new THREE.Box3().setFromObject(obj);
      const floorY = -ROOM_H * 0.5 + 0.02;
      obj.position.y += (floorY - bbox.min.y);
    }
    function autoScaleToRoom(obj){
      const bbox = new THREE.Box3().setFromObject(obj);
      const size = new THREE.Vector3(); bbox.getSize(size);
      const maxTarget = Math.min(ROOM_H * 0.38, ROOM_W * 0.38);
      return maxTarget / Math.max(size.x, size.y, size.z);
    }

    // Vase scaling controls
    let vaseBaseScale=1, vaseScaleMult=1, userScaleMult=1, userTallY=1.3;
    function applyVaseScale(){
      if(!vase) return;
      vaseScaleMult = isPortrait() ? 1.7 : 1.0;
      const s = vaseBaseScale * vaseScaleMult * userScaleMult;
      vase.scale.set(s, s*userTallY, s);
    }
    window.setVaseScale = m => { userScaleMult = Math.max(0.05, Number(m)||1); applyVaseScale(); };

    /* ---------- SPIN ---------- */
    let angVel=0, tilt=0, wobblePhase=0;
    let DAMPING=0.992, MIN_SPIN=0.18, IMPULSE_SCALE=0.0035;
    const TILT_FINAL=THREE.MathUtils.degToRad(7);
    let dragging=false, lastX=0, lastT=0;
    function getPointerX(e){ if(e.touches?.length) return e.touches[0].clientX; if(e.changedTouches?.length) return e.changedTouches[0].clientX; return e.clientX??0; }
    function onSwipeDown(e){ dragging=true; lastX=getPointerX(e); lastT=performance.now(); }
    function onSwipeMove(e){ if(!dragging) return; const now=performance.now(); const x=getPointerX(e); const dx=x-lastX; const dt=Math.max(1, now-lastT); angVel += (dx/dt)*IMPULSE_SCALE; lastX=x; lastT=now; }
    function onSwipeUp(){ dragging=false; }
    window.addEventListener('mousedown', onSwipeDown, {passive:true});
    window.addEventListener('mousemove', onSwipeMove, {passive:true});
    window.addEventListener('mouseup',   onSwipeUp,   {passive:true});
    window.addEventListener('touchstart',onSwipeDown, {passive:true});
    window.addEventListener('touchmove', onSwipeMove, {passive:true});
    window.addEventListener('touchend',  onSwipeUp,   {passive:true});

    /* ---------- TILT INPUT (gyro on phone, mouse on desktop) ---------- */
    let targetRX=0, targetRY=0; const MAX_TILT=0.085;
    const enableMotionBtn = document.getElementById('enableMotion');
    let baseBeta=null, baseGamma=null, pointerMoveAttached=false;

    function onPointerMoveDesktop(e){ const x=(e.clientX/vw())*2-1, y=(e.clientY/vh())*2-1; targetRY=x*MAX_TILT; targetRX=-y*MAX_TILT*0.6; }
    function onDeviceOrientation(e){
      if (baseBeta===null) baseBeta=e.beta||0;
      if (baseGamma===null) baseGamma=e.gamma||0;
      const dB=(e.beta||0)-baseBeta, dG=(e.gamma||0)-baseGamma;
      targetRY = THREE.MathUtils.clamp(dG/45,-1,1)*MAX_TILT;
      targetRX = -THREE.MathUtils.clamp(dB/60,-1,1)*(MAX_TILT*0.6);
    }
    function setupInputMode(){
      if (pointerMoveAttached){ window.removeEventListener('pointermove', onPointerMoveDesktop); pointerMoveAttached=false; }
      window.removeEventListener('deviceorientation', onDeviceOrientation, true);
      enableMotionBtn.style.display = 'none';
      if (isPortrait() && isTouch() && window.DeviceOrientationEvent){
        const needsPerm = typeof DeviceOrientationEvent.requestPermission === 'function';
        if (needsPerm){
          enableMotionBtn.style.display = 'block';
          enableMotionBtn.onclick = async ()=>{
            try { const resp=await DeviceOrientationEvent.requestPermission(); if(resp==='granted'){ window.addEventListener('deviceorientation', onDeviceOrientation, true); enableMotionBtn.remove(); } }
            catch(e){ console.warn(e); }
          };
        } else { window.addEventListener('deviceorientation', onDeviceOrientation, true); }
      } else {
        window.addEventListener('pointermove', onPointerMoveDesktop, {passive:true});
        pointerMoveAttached=true;
      }
    }

    /* ---------- CAMERA COVER (full-bleed) ---------- */
    let PORTRAIT_OVERSCAN = 1.28; // will be set by preset
    function updateCameraCover(){
      const openingZ = isPortrait()
        ? (room.position.z + ROOM_D*0.5)
        : (room.position.z + ROOM_D*0.0);
      const distance = Math.max(0.0001, camera.position.z - openingZ);
      const aspect = vw()/vh();
      const halfH = ROOM_H*0.5, halfW = ROOM_W*0.5;
      const requiredHalfHeight = Math.max(halfH, halfW / aspect);
      const exactVFOV = 2 * Math.atan(requiredHalfHeight / distance) * 180 / Math.PI;
      camera.fov = exactVFOV * (isPortrait() ? PORTRAIT_OVERSCAN : 1.10);
      camera.aspect = aspect;
      camera.updateProjectionMatrix();
    }

    /* ---------- POST FX ---------- */
    let rt = new THREE.WebGLRenderTarget(vw(), vh(), { minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, depthBuffer:true, stencilBuffer:false });
    const screenScene = new THREE.Scene();
    const screenCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);

    const fsQuad = new THREE.Mesh(
      new THREE.PlaneGeometry(2,2),
      new THREE.ShaderMaterial({
        uniforms:{
          tDiffuse: { value: rt.texture },
          resolution: { value: new THREE.Vector2(vw(), vh()) },
          pixelSize: { value: 6.0 },
          ditherStrength: { value: 0.25 }
        },
        vertexShader: `varying vec2 vUv; void main(){ vUv = uv; gl_Position = vec4(position, 1.0); }`,
        fragmentShader: `
          precision highp float;
          uniform sampler2D tDiffuse;
          uniform vec2 resolution;
          uniform float pixelSize;
          uniform float ditherStrength;
          varying vec2 vUv;
          float bayer(vec2 p){
            int x = int(mod(p.x, 4.0));
            int y = int(mod(p.y, 4.0));
            int m[16];
            m[0]=0; m[1]=8; m[2]=2; m[3]=10;
            m[4]=12; m[5]=4; m[6]=14; m[7]=6;
            m[8]=3; m[9]=11; m[10]=1; m[11]=9;
            m[12]=15; m[13]=7; m[14]=13; m[15]=5;
            int idx = y*4 + x;
            return float(m[idx]) / 16.0;
          }
          void main(){
            vec2 px = vec2(pixelSize);
            vec2 uv = floor(vUv * resolution / px) * px / resolution;
            vec3 col = texture2D(tDiffuse, uv).rgb;
            float luma = dot(col, vec3(0.2126,0.7152,0.0722));
            vec2 grid = floor(vUv * resolution / px);
            float thresh = bayer(grid);
            float d = smoothstep(0.0, 1.0, luma + (thresh - 0.5) * ditherStrength);
            col = mix(col*0.9, col*1.1, d);
            gl_FragColor = vec4(col, 1.0);
          }
        `
      })
    );
    screenScene.add(fsQuad);

    function resizePost(){
      rt.setSize(vw(), vh());
      fsQuad.material.uniforms.resolution.value.set(vw(), vh());
    }

    /* ---------- RESIZE / LAYOUT ---------- */
    function updateLayout(){
      renderer.setSize(vw(), vh(), false);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, isPortrait() ? 1.5 : 1.8));
      resizePost();
      updateCameraCover();
      applyVaseScale();
      setupInputMode();
      key.position.set(1.5, -ROOM_H*0.1, room.position.z + ROOM_D*0.05);
    }
    window.addEventListener('resize', updateLayout);
    window.addEventListener('orientationchange', updateLayout);
    if (window.visualViewport) window.visualViewport.addEventListener('resize', updateLayout);

    // hard-disable page scroll
    window.addEventListener('touchmove', e=>e.preventDefault(), {passive:false});
    window.addEventListener('wheel',     e=>e.preventDefault(), {passive:false});

    /* ---------- RENDER LOOP ---------- */
    const clock = new THREE.Clock();
    const tmp = new THREE.Vector3();

    function updateVase(dt){
      if(!vaseReady) return;
      angVel *= Math.pow(DAMPING, dt*60);
      const floor = (angVel>=0 ? MIN_SPIN : -MIN_SPIN);
      if (Math.abs(angVel) < Math.abs(floor)) angVel = floor;

      vaseGroup.rotation.y += angVel * dt;

      tilt += (TILT_FINAL - tilt) * Math.min(1, dt*2.5);
      const wobbleFreq = Math.max(0.8, Math.abs(angVel)*2.2);
      wobblePhase += wobbleFreq * dt;
      const wobbleAmp = THREE.MathUtils.clamp(0.12 - Math.min(0.1, Math.abs(angVel)*0.08), 0.02, 0.08);
      vaseGroup.rotation.x = tilt + Math.sin(wobblePhase) * wobbleAmp;
      vaseGroup.rotation.z = Math.cos(wobblePhase*0.9) * wobbleAmp * 0.6;
    }

    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.033);

      if (wallShaderRef){ wallShaderRef.uniforms.uTime.value += dt; }

      if (vaseReady && vase){
        vase.visible = false;
        cubeCam.position.copy(vaseGroup.getWorldPosition(tmp));
        cubeCam.update(renderer, scene);
        vase.visible = true;
      }

      room.rotation.x += (targetRX - room.rotation.x) * 0.06;
      room.rotation.y += (targetRY - room.rotation.y) * 0.06;
      edges.rotation.copy(room.rotation);

      updateVase(dt);

      renderer.setRenderTarget(rt);
      renderer.render(scene, camera);
      renderer.setRenderTarget(null);
      renderer.render(screenScene, screenCam);
    }

    /* ---------- UI BINDING ---------- */
    const $ = id => document.getElementById(id);
    const panel = $('panel'), gear = $('gear');
    gear.onclick = ()=> { panel.style.display = (panel.style.display !== 'none') ? 'none' : 'block'; };

    const params = {
      width: ROOM_W, height: ROOM_H, depth: ROOM_D,
      roomZ: room.position.z,
      overscan: PORTRAIT_OVERSCAN,
      zoom: 1.0,
      edgeOpacity: edges.material.opacity,
      emissive: wallMat.emissiveIntensity,

      // lights
      exposure: renderer.toneMappingExposure,
      ambientI: 0.25,
      hemiI: hemi.intensity,
      rimI: rim.intensity,
      keyI: key.intensity,

      // vase
      vaseMul: 1.2,
      vaseTall: 1.3,
      vaseZ: vaseGroup.position.z,
      vaseY: vaseGroup.position.y,

      // spin
      damping: DAMPING,
      minSpin: MIN_SPIN,
      impulse: IMPULSE_SCALE,

      // post
      pixelSize: 6,
      dither: 0.25,

      // walls FX
      dispAmp: 0.02,
      dispSpeed: 1.5
    };

    function bindRange(numId, rangeId, key, onChange){
      const num=$(numId), range=$(rangeId);
      num.value = params[key]; range.value = params[key];
      const sync=(v)=>{
        const val = +v;
        params[key]=val; num.value=val; range.value=val;
        onChange(val);
      };
      num.addEventListener('change', e=>sync(e.target.value));
      range.addEventListener('input', e=>sync(e.target.value));
    }

    function rebuildRoom(){
      const newGeo = buildRoomGeometry(params.width, params.height, params.depth);
      ROOM_W=params.width; ROOM_H=params.height; ROOM_D=params.depth;
      room.geometry.dispose(); room.geometry=newGeo;

      edges.geometry.dispose(); edges.geometry=new THREE.EdgesGeometry(newGeo);

      key.position.set(1.5, -ROOM_H*0.1, room.position.z + ROOM_D*0.05);
      placeOnFloor(vaseGroup);
      updateLayout();
    }

    // Size
    bindRange('wNum','w','width',  rebuildRoom);
    bindRange('hNum','h','height', rebuildRoom);
    bindRange('dNum','d','depth',  rebuildRoom);

    // Framing
    bindRange('zNum','z','roomZ', (v)=>{
      room.position.z = v; edges.position.copy(room.position);
      updateLayout();
    });
    bindRange('ovNum','ov','overscan', (v)=>{
      PORTRAIT_OVERSCAN = v; updateLayout();
    });

    // Appearance
    bindRange('zoomNum','zoom','zoom', v=> applyTextureZoom(tex, v));
    bindRange('edgeNum','edge','edgeOpacity', v=>{ edges.material.opacity = Math.max(0, Math.min(1, v)); edges.material.needsUpdate=true; });
    bindRange('emisNum','emis','emissive', v=>{ wallMat.emissiveIntensity = Math.max(0, v); wallMat.needsUpdate=true; });

    // Lights / Brightness
    bindRange('expNum','exp','exposure', v=>{ renderer.toneMappingExposure = Math.max(0.01, v); });
    bindRange('ambNum','amb','ambientI', v=>{ ambient.intensity = Math.max(0, v); });
    bindRange('hemiNum','hemi','hemiI', v=>{ hemi.intensity = Math.max(0, v); });
    bindRange('rimNum','rim','rimI', v=>{ rim.intensity = Math.max(0, v); });
    bindRange('keyINum','keyI','keyI', v=>{ key.intensity = Math.max(0, v); });

    // Vase
    bindRange('vaseNum','vase','vaseMul', v=>{ userScaleMult = Math.max(0.05, v); applyVaseScale(); });
    bindRange('vaseYNum','vaseY','vaseTall', v=>{ userTallY = Math.max(0.05, v); applyVaseScale(); });
    function syncVasePositionInputs(){
      $('vaseZ').value = $('vaseZNum').value = vaseGroup.position.z;
      $('vaseYPos').value = $('vaseYPosNum').value = vaseGroup.position.y;
    }
    bindRange('vaseZNum','vaseZ','vaseZ', v=>{ vaseGroup.position.z = v; });
    bindRange('vaseYPosNum','vaseYPos','vaseY', v=>{ vaseGroup.position.y = v; });

    // Spin
    bindRange('dampNum','damp','damping', v=> DAMPING = v);
    bindRange('minNum','min','minSpin', v=> MIN_SPIN = v);
    bindRange('impNum','imp','impulse', v=> IMPULSE_SCALE = v);

    // FX ‚Äì screen
    bindRange('pixNum','pix','pixelSize', v=> fsQuad.material.uniforms.pixelSize.value = Math.max(1, v|0));
    bindRange('dithNum','dith','dither', v=> fsQuad.material.uniforms.ditherStrength.value = Math.max(0, v));

    // FX ‚Äì walls
    bindRange('dispNum','disp','dispAmp', v=>{ if(wallShaderRef) wallShaderRef.uniforms.uDispAmp.value = v; });
    bindRange('dsNum','ds','dispSpeed', v=>{ if(wallShaderRef) wallShaderRef.uniforms.uDispSpeed.value = v; });

    // Quick fit buttons
    document.getElementById('fitPortrait').onclick = ()=>{
      params.roomZ = -params.depth * 0.5;
      $('z').value = $('zNum').value = params.roomZ;
      room.position.z = params.roomZ; edges.position.copy(room.position);
      PORTRAIT_OVERSCAN = params.overscan = Math.max(1.28, PORTRAIT_OVERSCAN);
      $('ov').value = $('ovNum').value = PORTRAIT_OVERSCAN;
      updateLayout();
    };
    document.getElementById('fitDesktop').onclick = ()=>{
      params.roomZ = -params.depth * 0.5;
      $('z').value = $('zNum').value = params.roomZ;
      room.position.z = params.roomZ; edges.position.copy(room.position);
      PORTRAIT_OVERSCAN = params.overscan = 1.10;
      $('ov').value = $('ovNum').value = 1.10;
      updateLayout();
    };

    // Vase light UI (binds once vaseLight exists)
    function bindVaseLightUI(){
      if (!vaseLight) return;
      const set = (numId, rangeId, getVal, setVal)=>{
        const num=$(numId), range=$(rangeId);
        const init=getVal(); num.value=init; range.value=init;
        const sync=(v)=>{ v=+v; setVal(v); num.value=v; range.value=v; };
        num.addEventListener('change', e=>sync(e.target.value));
        range.addEventListener('input', e=>sync(e.target.value));
      };
      set('vliNum','vli', ()=>vaseLight.intensity, v=> vaseLight.intensity = Math.max(0, v));
      set('vldNum','vld', ()=>vaseLight.distance,  v=> vaseLight.distance  = Math.max(0, v));
      set('vlcNum','vlc', ()=>vaseLight.decay,     v=> vaseLight.decay     = Math.max(0.01, v));
      set('vlyNum','vly', ()=>vaseLight.position.y,v=> vaseLight.position.y = v);
    }

    /* ---------- SAVE/LOAD HELPERS ---------- */
    window.dumpControls = async (copyToClipboard = true) => {
      const data = {
        room: {
          width: ROOM_W,
          height: ROOM_H,
          depth: ROOM_D,
          positionZ: room.position.z,
          portraitOverscan: PORTRAIT_OVERSCAN,
          imageZoom: tex?.repeat ? (1 / tex.repeat.x) : 1,
          borderOpacity: edges.material.opacity,
          wallEmissive: wallMat.emissiveIntensity,
          wallDispAmp: wallShaderRef ? wallShaderRef.uniforms.uDispAmp.value : null,
          wallDispSpeed: wallShaderRef ? wallShaderRef.uniforms.uDispSpeed.value : null,
        },
        lights: {
          exposure: renderer.toneMappingExposure,
          ambient: ambient?.intensity ?? null,
          hemisphere: hemi?.intensity ?? null,
          rim: rim?.intensity ?? null,
          key: key?.intensity ?? null,
          vaseLight: vaseLight ? {
            intensity: vaseLight.intensity,
            distance: vaseLight.distance,
            decay: vaseLight.decay,
            y: vaseLight.position.y,
          } : null,
        },
        vase: {
          userScaleMult,
          userTallY,
          z: vaseGroup.position.z,
          y: vaseGroup.position.y,
        },
        spin: { damping: DAMPING, minSpin: MIN_SPIN, swipeImpulse: IMPULSE_SCALE },
        post: { pixelSize: fsQuad.material.uniforms.pixelSize.value, ditherStrength: fsQuad.material.uniforms.ditherStrength.value }
      };
      console.log("üîß Controls object:", data);
      const json = JSON.stringify(data, null, 2);
      console.log("üîß Controls JSON:\n", json);
      try {
        if (copyToClipboard && navigator.clipboard?.writeText) {
          await navigator.clipboard.writeText(json);
          console.log("üìã Copied controls JSON to clipboard.");
        }
      } catch (e) { console.warn("Clipboard copy failed:", e); }
      return data;
    };

    window.applyControls = (cfg) => {
      if (!cfg || typeof cfg !== 'object') { console.warn("applyControls: invalid data"); return; }

      // Room
      if (cfg.room) {
        const r = cfg.room;
        if (typeof r.width  === 'number') params.width  = r.width;
        if (typeof r.height === 'number') params.height = r.height;
        if (typeof r.depth  === 'number') params.depth  = r.depth;
        rebuildRoom();

        if (typeof r.positionZ === 'number') { params.roomZ = r.positionZ; room.position.z = r.positionZ; edges.position.copy(room.position); }
        if (typeof r.portraitOverscan === 'number') { PORTRAIT_OVERSCAN = r.portraitOverscan; params.overscan = r.portraitOverscan; }
        if (typeof r.imageZoom === 'number') { params.zoom = r.imageZoom; applyTextureZoom(tex, r.imageZoom); }
        if (typeof r.borderOpacity === 'number') { params.edgeOpacity = r.borderOpacity; edges.material.opacity = r.borderOpacity; edges.material.needsUpdate = true; }
        if (typeof r.wallEmissive === 'number') { params.emissive = r.wallEmissive; wallMat.emissiveIntensity = r.wallEmissive; wallMat.needsUpdate = true; }
        if (typeof r.wallDispAmp === 'number' && wallShaderRef)  wallShaderRef.uniforms.uDispAmp.value   = r.wallDispAmp;
        if (typeof r.wallDispSpeed === 'number' && wallShaderRef) wallShaderRef.uniforms.uDispSpeed.value = r.wallDispSpeed;
      }

      // Lights
      if (cfg.lights) {
        const L = cfg.lights;
        if (typeof L.exposure === 'number') renderer.toneMappingExposure = Math.max(0.01, L.exposure);
        if (typeof L.ambient === 'number' && ambient) ambient.intensity = Math.max(0, L.ambient);
        if (typeof L.hemisphere === 'number' && hemi) hemi.intensity = Math.max(0, L.hemisphere);
        if (typeof L.rim === 'number' && rim) rim.intensity = Math.max(0, L.rim);
        if (typeof L.key === 'number' && key) key.intensity = Math.max(0, L.key);
        if (L.vaseLight && vaseLight) {
          const v = L.vaseLight;
          if (typeof v.intensity === 'number') vaseLight.intensity = Math.max(0, v.intensity);
          if (typeof v.distance  === 'number') vaseLight.distance  = Math.max(0, v.distance);
          if (typeof v.decay     === 'number') vaseLight.decay     = Math.max(0.01, v.decay);
          if (typeof v.y         === 'number') vaseLight.position.y = v.y;
        }
      }

      // Vase
      if (cfg.vase) {
        const V = cfg.vase;
        if (typeof V.userScaleMult === 'number') userScaleMult = Math.max(0.05, V.userScaleMult);
        if (typeof V.userTallY     === 'number') userTallY     = Math.max(0.05, V.userTallY);
        applyVaseScale();
        if (typeof V.z === 'number') vaseGroup.position.z = V.z;
        if (typeof V.y === 'number') vaseGroup.position.y = V.y;
      }

      // Spin
      if (cfg.spin) {
        const S = cfg.spin;
        if (typeof S.damping      === 'number') DAMPING        = S.damping;
        if (typeof S.minSpin      === 'number') MIN_SPIN       = S.minSpin;
        if (typeof S.swipeImpulse === 'number') IMPULSE_SCALE  = S.swipeImpulse;
      }

      // Post
      if (cfg.post) {
        const P = cfg.post;
        if (typeof P.pixelSize === 'number') fsQuad.material.uniforms.pixelSize.value = Math.max(1, P.pixelSize|0);
        if (typeof P.ditherStrength === 'number') fsQuad.material.uniforms.ditherStrength.value = Math.max(0, P.ditherStrength);
      }

      updateLayout();
      console.log("‚úÖ Applied controls from object.");
    };

    // Sync the panel inputs to reflect live scene values (after preset)
    function syncPanelFromLive(){
      const set = (id, v)=>{ const el=$(id); if(el){ el.value = v; } };
      // Size
      set('w', ROOM_W); set('wNum', ROOM_W);
      set('h', ROOM_H); set('hNum', ROOM_H);
      set('d', ROOM_D); set('dNum', ROOM_D);
      // Framing
      set('z', room.position.z); set('zNum', room.position.z);
      set('ov', PORTRAIT_OVERSCAN); set('ovNum', PORTRAIT_OVERSCAN);
      // Appearance
      const imgZoom = tex?.repeat ? (1/tex.repeat.x) : 1;
      set('zoom', imgZoom); set('zoomNum', imgZoom);
      set('edge', edges.material.opacity); set('edgeNum', edges.material.opacity);
      set('emis', wallMat.emissiveIntensity); set('emisNum', wallMat.emissiveIntensity);
      // Lights
      set('exp', renderer.toneMappingExposure); set('expNum', renderer.toneMappingExposure);
      set('amb', ambient.intensity); set('ambNum', ambient.intensity);
      set('hemi', hemi.intensity); set('hemiNum', hemi.intensity);
      set('rim', rim.intensity); set('rimNum', rim.intensity);
      set('keyI', key.intensity); set('keyINum', key.intensity);
      // Vase
      set('vase', userScaleMult); set('vaseNum', userScaleMult);
      set('vaseY', userTallY); set('vaseYNum', userTallY);
      set('vaseZ', vaseGroup.position.z); set('vaseZNum', vaseGroup.position.z);
      set('vaseYPos', vaseGroup.position.y); set('vaseYPosNum', vaseGroup.position.y);
      // Spin
      set('damp', DAMPING); set('dampNum', DAMPING);
      set('min', MIN_SPIN); set('minNum', MIN_SPIN);
      set('imp', IMPULSE_SCALE); set('impNum', IMPULSE_SCALE);
      // Post
      const px = fsQuad.material.uniforms.pixelSize.value;
      const di = fsQuad.material.uniforms.ditherStrength.value;
      set('pix', px); set('pixNum', px);
      set('dith', di); set('dithNum', di);
      // Walls FX
      if (wallShaderRef){
        const da = wallShaderRef.uniforms.uDispAmp.value;
        const ds = wallShaderRef.uniforms.uDispSpeed.value;
        set('disp', da); set('dispNum', da);
        set('ds', ds); set('dsNum', ds);
      }
      // Vase light (if ready)
      if (vaseLight){
        set('vli', vaseLight.intensity); set('vliNum', vaseLight.intensity);
        set('vld', vaseLight.distance); set('vldNum', vaseLight.distance);
        set('vlc', vaseLight.decay); set('vlcNum', vaseLight.decay);
        set('vly', vaseLight.position.y); set('vlyNum', vaseLight.position.y);
      }
    }

    /* ---------- STARTUP ---------- */
    updateLayout();
    setupInputMode();

    // Apply chosen preset immediately (room/lights/post)
    applyControls(START_PRESET);
    syncPanelFromLive();

    // Start loop
    animate();

  </script>
</body>
</html>
