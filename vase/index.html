<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"
  />
  <title>Mysterious Room ‚Äî Album Promo (popup on spin)</title>
  <style>
    /* Full viewport & lock scroll */
    html, body { height: 100dvh; width: 100vw; }
    body {
      margin: 0; background: #000; overflow: hidden;
      overscroll-behavior: none; touch-action: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;
    }
    canvas { display: block; width: 100vw !important; height: 100dvh !important; }

    /* Control panel (unchanged except toggle) */
    .panel {
      position: fixed; top: 12px; left: 12px; z-index: 20;
      width: min(94vw, 420px);
      max-height: calc(100dvh - 24px);
      overflow: hidden;
      border-radius: 14px; backdrop-filter: blur(8px);
      background: #0b1020e0; border: 1px solid #88a7ff2a; color: #eaf0ff;
      box-shadow: 0 8px 28px #000a; font-size: 12px; letter-spacing: .02em;
      display: none;
    }
    .tabs {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      padding: 8px;
      background: #0f1a38a6;
      border-bottom: 1px solid #5c75b42a;
    }
    .tab-btn {
      padding: 8px 10px; border-radius: 10px; border:1px solid #6aa2ff33;
      background:#0e1736; color:#d9e6ff; cursor:pointer; text-align:center;
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .tab-btn.active { background:#1a2a62; border-color:#89a6ff66; color:#eaf0ff; }
    .tabpages { padding: 10px; overflow: auto; max-height: calc(100dvh - 120px); }
    .tabpage { display: none; }
    .tabpage.active { display: block; }
    h3 { margin: 4px 0 10px; font-size: 13px; color:#cfe0ff; }
    .row { display: grid; grid-template-columns: 1fr 60px; gap: 8px; align-items: center; margin: 6px 0; }
    .row input[type="range"] { width: 100%; }
    .row input[type="number"] {
      width: 60px; background:#0d1a3a; color:#eaf0ff; border:1px solid #446;
      border-radius:6px; padding:4px 6px; font-size:12px;
    }
    .two { display:flex; gap:8px; margin-top:8px; }
    .two > button {
      flex:1 1 0; padding:8px 10px; border-radius:10px; border:1px solid #6aa2ff33;
      background:#0e1736; color:#d9e6ff; cursor:pointer;
    }
    .inline { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .swatch { display:flex; gap:6px; }
    .swatch input[type="number"] { width:52px; }

    #gear {
      position: fixed; right: 12px; bottom: 12px; z-index: 21;
      width: 44px; height: 44px; border-radius: 50%;
      border: 1px solid #6aa2ff55; background:#0e1736; color:#dce8ff;
      display: grid; place-items: center; font-size: 20px; cursor: pointer;
      box-shadow: 0 8px 24px #000a;
    }
    #enableMotion {
      position: fixed; inset: auto 16px 66px auto; z-index: 22;
      padding: 10px 14px; border-radius: 12px; border: 1px solid #6aa2ff33;
      background: #0b1020; color: #cfe0ff; font: 600 12px/1.2 system-ui;
      letter-spacing: .05em; box-shadow: 0 6px 20px #0007; display: none;
    }

    /* ---------- Spin Popup ---------- */
    .popup-wrap {
      position: fixed; inset: 0; z-index: 30; display: none;
      align-items: center; justify-content: center;
      background: rgba(0,0,0,0.35); /* subtle dim */
      backdrop-filter: blur(2px);
    }
    .popup {
      position: relative;
      width: min(92vw, 420px);
      max-width: 92vw;
      padding: 16px 14px 14px;
      border-radius: 16px;
      /* blocky / pixel grid frame */
      background:
        repeating-linear-gradient(0deg, #1a2350 0 2px, #0e1638 2px 4px),
        linear-gradient(180deg, #122058cc, #0a1234cc);
      border: 2px solid #8fb0ff66;
      box-shadow:
        0 0 0 4px #1b2c6a88 inset,
        0 10px 28px #000a,
        0 0 40px #7da5ff33 inset;
      color: #eaf0ff;
      transform: translateY(8px) scale(0.98);
      opacity: 0;
      transition: transform .22s ease, opacity .22s ease;
      image-rendering: pixelated;
    }
    .popup.show { transform: translateY(0) scale(1); opacity: 1; }
    .popup h4 {
      margin: 0 0 10px; font-size: 16px; letter-spacing: .04em; color:#cfe0ff;
      text-shadow: 0 1px 0 #000, 0 0 14px #89a6ff66;
    }
    .popup p { margin: 0 0 12px; font-size: 12px; opacity: .9; }

    .popup-buttons {
      display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 8px;
    }
    .btn-tile {
      display: grid; grid-template-columns: 32px 1fr; align-items: center; gap: 10px;
      padding: 10px 12px; border-radius: 12px; cursor: pointer; text-decoration: none;
      border: 1px solid #8fb0ff55; background: #0c1538aa; color: #cfe0ff;
      box-shadow: 0 2px 0 #000a inset, 0 0 16px #6aa2ff22 inset;
      transition: transform .08s ease, box-shadow .12s ease;
    }
    .btn-tile:active { transform: translateY(1px) scale(0.995); }
    .btn-label { font-size: 13px; font-weight: 700; letter-spacing: .03em; }

    /* Stylized logos (SVG) get slight pixel vibe via drop shadows */
    .logo { width: 32px; height: 32px; filter: drop-shadow(0 0 8px #88a7ff55); }

    .popup-close {
      position: absolute; right: 8px; top: 8px;
      width: 28px; height: 28px; border-radius: 8px;
      display: grid; place-items: center; cursor: pointer;
      border: 1px solid #8fb0ff55; background: #0c1538cc; color:#eaf0ff;
      font-size: 16px; line-height: 1; user-select: none;
      box-shadow: 0 2px 0 #000a inset, 0 0 12px #6aa2ff22 inset;
      transition: transform .08s ease;
    }
    .popup-close:active { transform: translateY(1px) scale(0.98); }

    /* Phone-friendly sizing */
    @media (max-width: 600px) {
      .popup { width: min(94vw, 440px); border-width: 2px; }
      .popup-buttons { gap: 8px; }
      .btn-tile { grid-template-columns: 28px 1fr; padding: 10px; }
      .logo { width: 28px; height: 28px; }
    }
  </style>
</head>
<body>

  <!-- Controls panel (same structure as your last working build) -->
  <div class="panel" id="panel">
    <div class="tabs" id="tabs">
      <button class="tab-btn active" data-tab="vaseTab">vase</button>
      <button class="tab-btn" data-tab="roomTab">room size & framing</button>
      <button class="tab-btn" data-tab="wallImgTab">wall image controls</button>
      <button class="tab-btn" data-tab="lightsTab">lights controls</button>
      <button class="tab-btn" data-tab="roomFxTab">room effects</button>
      <button class="tab-btn" data-tab="waterTab">water effects</button>
      <button class="tab-btn" data-tab="globalFxTab">global effects</button>
      <button class="tab-btn" data-tab="vaseFxTab">vase effects</button>
    </div>

    <div class="tabpages">
      <!-- Vase -->
      <div class="tabpage active" id="vaseTab">
        <h3>Vase</h3>
        <div class="row"><label>Scale √ó</label><input id="vaseNum" type="number" step="0.01"><input id="vase" type="range" min="0.2" max="4.0" step="0.01"></div>
        <div class="row"><label>Tallness (Y)</label><input id="vaseYNum" type="number" step="0.01"><input id="vaseY" type="range" min="0.5" max="3.0" step="0.01"></div>
        <div class="row"><label>Pos Z</label><input id="vaseZNum" type="number" step="0.1"><input id="vaseZ" type="range" min="-40" max="2" step="0.1"></div>
        <div class="row"><label>Pos Y</label><input id="vaseYPosNum" type="number" step="0.1"><input id="vaseYPos" type="range" min="-10" max="8" step="0.1"></div>
        <h3>Spin</h3>
        <div class="row"><label>Damping</label><input id="dampNum" type="number" step="0.001"><input id="damp" type="range" min="0.90" max="0.999" step="0.001"></div>
        <div class="row"><label>Min Spin</label><input id="minNum" type="number" step="0.01"><input id="min" type="range" min="0.0" max="0.6" step="0.01"></div>
        <div class="row"><label>Swipe Impulse</label><input id="impNum" type="number" step="0.0001"><input id="imp" type="range" min="0.0005" max="0.02" step="0.0001"></div>
      </div>

      <!-- Room size & framing -->
      <div class="tabpage" id="roomTab">
        <h3>Room Size</h3>
        <div class="row"><label>Width</label><input id="wNum" type="number" step="0.1"><input id="w" type="range" min="3" max="30" step="0.1"></div>
        <div class="row"><label>Height</label><input id="hNum" type="number" step="0.1"><input id="h" type="range" min="3" max="24" step="0.1"></div>
        <div class="row"><label>Depth</label><input id="dNum" type="number" step="0.1"><input id="d" type="range" min="3" max="40" step="0.1"></div>
        <h3>Framing</h3>
        <div class="row"><label>Room Z</label><input id="zNum" type="number" step="0.1"><input id="z" type="range" min="-40" max="0" step="0.1"></div>
        <div class="row"><label>Portrait Overscan</label><input id="ovNum" type="number" step="0.01"><input id="ov" type="range" min="1.10" max="1.70" step="0.01"></div>
        <div class="two">
          <button id="fitPortrait">Fit (Portrait)</button>
          <button id="fitDesktop">Fit (Desktop)</button>
        </div>
      </div>

      <!-- Wall image controls -->
      <div class="tabpage" id="wallImgTab">
        <h3>Wall Image</h3>
        <div class="row"><label>Image Zoom</label><input id="zoomNum" type="number" step="0.01"><input id="zoom" type="range" min="0.5" max="3.0" step="0.01"></div>
        <div class="row"><label>Border Opacity</label><input id="edgeNum" type="number" step="0.01"><input id="edge" type="range" min="0" max="1" step="0.01"></div>
      </div>

      <!-- Lights controls -->
      <div class="tabpage" id="lightsTab">
        <h3>Lights</h3>
        <div class="row"><label>Exposure</label><input id="expNum" type="number" step="0.01"><input id="exp" type="range" min="0.2" max="3.0" step="0.01"></div>
        <div class="row"><label>Ambient</label><input id="ambNum" type="number" step="0.01"><input id="amb" type="range" min="0" max="3" step="0.01"></div>
        <div class="row"><label>Hemisphere</label><input id="hemNum" type="number" step="0.01"><input id="hem" type="range" min="0" max="3" step="0.01"></div>
        <div class="row"><label>Rim</label><input id="rimNum" type="number" step="0.01"><input id="rim" type="range" min="0" max="4" step="0.01"></div>
        <div class="row"><label>Key</label><input id="keyNum" type="number" step="0.01"><input id="key" type="range" min="0" max="4" step="0.01"></div>
        <h3>Vase Light</h3>
        <div class="row"><label>Intensity</label><input id="vlINum" type="number" step="0.01"><input id="vlI" type="range" min="0" max="10" step="0.01"></div>
        <div class="row"><label>Distance</label><input id="vlDNum" type="number" step="0.1"><input id="vlD" type="range" min="0.1" max="30" step="0.1"></div>
        <div class="row"><label>Decay</label><input id="vlDecNum" type="number" step="0.1"><input id="vlDec" type="range" min="0" max="3" step="0.1"></div>
        <div class="row"><label>Y Position</label><input id="vlYNum" type="number" step="0.01"><input id="vlY" type="range" min="-4" max="4" step="0.01"></div>
      </div>

      <!-- Room effects -->
      <div class="tabpage" id="roomFxTab">
        <h3>Room Effects</h3>
        <div class="row"><label>Wall Emissive</label><input id="emisNum" type="number" step="0.01"><input id="emis" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>Disp Amp</label><input id="dispNum" type="number" step="0.001"><input id="disp" type="range" min="0" max="0.15" step="0.001"></div>
        <div class="row"><label>Disp Speed</label><input id="dsNum" type="number" step="0.01"><input id="ds" type="range" min="0" max="8" step="0.01"></div>
      </div>

      <!-- Water effects -->
      <div class="tabpage" id="waterTab">
        <h3>Water (visible & fast)</h3>
        <div class="row"><label>Amplitude</label><input id="wAmpNum" type="number" step="0.01"><input id="wAmp" type="range" min="0" max="3.0" step="0.01"></div>
        <div class="row"><label>Frequency</label><input id="wFreqNum" type="number" step="0.1"><input id="wFreq" type="range" min="1" max="40" step="0.1"></div>
        <div class="row"><label>Wave Speed</label><input id="wSpeedNum" type="number" step="0.01"><input id="wSpeed" type="range" min="0" max="8" step="0.01"></div>
        <div class="row"><label>Falloff</label><input id="wFallNum" type="number" step="0.01"><input id="wFall" type="range" min="0.1" max="4.0" step="0.01"></div>
        <div class="row"><label>Alpha</label><input id="wAlphaNum" type="number" step="0.01"><input id="wAlpha" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>Radius</label><input id="wRadNum" type="number" step="0.1"><input id="wRad" type="range" min="0.5" max="8.0" step="0.1"></div>
        <div class="row"><label>Pixelation</label><input id="wPixNum" type="number" step="1"><input id="wPix" type="range" min="1" max="24" step="1"></div>
        <div class="row"><label>Y Offset</label><input id="wYNum" type="number" step="0.01"><input id="wY" type="range" min="-3" max="3" step="0.01"></div>
        <div class="inline">
          <span>Tint (RGB 0..1)</span>
          <div class="swatch">
            <input id="wR" type="number" min="0" max="1" step="0.01">
            <input id="wG" type="number" min="0" max="1" step="0.01">
            <input id="wB" type="number" min="0" max="1" step="0.01">
          </div>
        </div>
      </div>

      <!-- Global effects -->
      <div class="tabpage" id="globalFxTab">
        <h3>Global Effects</h3>
        <div class="row"><label>Pixel Size</label><input id="pixNum" type="number" step="1"><input id="pix" type="range" min="1" max="24" step="1"></div>
        <div class="row"><label>Dither Strength</label><input id="dithNum" type="number" step="0.01"><input id="dith" type="range" min="0" max="1" step="0.01"></div>
      </div>

      <!-- Vase effects -->
      <div class="tabpage" id="vaseFxTab">
        <h3>Glass Material (live)</h3>
        <div class="row"><label>Transmission</label><input id="glassTransNum" type="number" step="0.01"><input id="glassTrans" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>Thickness</label><input id="glassThickNum" type="number" step="0.01"><input id="glassThick" type="range" min="0.1" max="4" step="0.01"></div>
        <div class="row"><label>IOR</label><input id="glassIorNum" type="number" step="0.01"><input id="glassIor" type="range" min="1.0" max="2.5" step="0.01"></div>
        <div class="row"><label>Roughness</label><input id="glassRoughNum" type="number" step="0.01"><input id="glassRough" type="range" min="0.0" max="1.0" step="0.01"></div>
        <div class="row"><label>Clearcoat</label><input id="glassCCNum" type="number" step="0.01"><input id="glassCC" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>CC Roughness</label><input id="glassCCRNum" type="number" step="0.01"><input id="glassCCR" type="range" min="0" max="1" step="0.01"></div>
        <div class="row"><label>Env Intensity</label><input id="glassEnvNum" type="number" step="0.01"><input id="glassEnv" type="range" min="0" max="4" step="0.01"></div>
      </div>
    </div>
  </div>

  <button id="gear" aria-label="Toggle controls">‚öôÔ∏è</button>
  <button id="enableMotion">Enable Motion</button>

  <!-- Spin Popup -->
  <div class="popup-wrap" id="spinPopupWrap" aria-hidden="true">
    <div class="popup" id="spinPopup" role="dialog" aria-modal="true" aria-labelledby="popTitle">
      <button class="popup-close" id="popClose" aria-label="Close">‚úï</button>
      <h4 id="popTitle">you unlocked the portal</h4>
      <p>that spin was üî• ‚Äî want to jump in?</p>
      <div class="popup-buttons">
        <!-- Spotify -->
        <a class="btn-tile" id="btnSpotify" href="#" target="_blank" rel="noopener">
          <svg class="logo" viewBox="0 0 64 64" aria-hidden="true">
            <rect x="2" y="2" width="60" height="60" rx="12" fill="#1DB954"/>
            <path d="M15 26c13-5 21-4 33 1" stroke="#0b2a12" stroke-width="6" stroke-linecap="round" fill="none"/>
            <path d="M16 36c10-4 18-3 30 1" stroke="#0b2a12" stroke-width="5" stroke-linecap="round" fill="none" opacity=".9"/>
            <path d="M17 44c8-3 14-2 24 1" stroke="#0b2a12" stroke-width="4" stroke-linecap="round" fill="none" opacity=".8"/>
          </svg>
          <span class="btn-label">Spotify</span>
        </a>
        <!-- Apple Music -->
        <a class="btn-tile" id="btnApple" href="#" target="_blank" rel="noopener">
          <svg class="logo" viewBox="0 0 64 64" aria-hidden="true">
            <rect x="2" y="2" width="60" height="60" rx="12" fill="#fb2d61"/>
            <path d="M42 14l-18 4v22c0 2-2 4-5 4s-5-2-5-4 2-4 5-4c2 0 4 1 5 2V22l18-4v16c0 2-2 4-5 4s-5-2-5-4 2-4 5-4c2 0 4 1 5 2V14z"
                  fill="#380410" opacity=".9"/>
          </svg>
          <span class="btn-label">Apple&nbsp;Music</span>
        </a>
      </div>
    </div>
  </div>

  <!-- three.js -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    /* -------------------- helpers & environment -------------------- */
    const vw = ()=> (window.visualViewport?.width  || window.innerWidth);
    const vh = ()=> (window.visualViewport?.height || window.innerHeight);
    const isPortrait = ()=> vh() >= vw();
    const isTouch = ()=> ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    const isPhone = ()=> isTouch() && (Math.min(vw(), vh()) < 820);

    /* -------------------- presets (desktop vs phone) -------------------- */
    const desktopDefaults = {
      room:{ width:18.3, height:13.3, depth:24.0, positionZ:-4.7, portraitOverscan:1.31, imageZoom:0.90, borderOpacity:0.00, wallEmissive:0.35, wallDispAmp:0.018, wallDispSpeed:3.26 },
      lights:{ exposure:0.86, ambient:1.91, hemisphere:2.0, rim:1.87, key:1.68, vaseLight:{ intensity:6.0, distance:8.6, decay:1.6, y:0.08 } },
      vase:{ userScaleMult:2.62, userTallY:1.35, z:-8.0, y:-2.2 },
      spin:{ damping:0.973, minSpin:0.10, swipeImpulse:0.0085 },
      post:{ pixelSize:6, ditherStrength:0.13 },
      water:{ amp:1.2, freq:18.0, speed:2.2, falloff:1.2, alpha:0.65, radius:4.0, pixel:4, yOffset:0.0, tint:[0.45, 0.75, 1.0] },
      glass:{ transmission:1.0, thickness:1.4, ior:1.52, roughness:0.05, clearcoat:1.0, ccRough:0.05, envIntensity:1.9 }
    };
    const phoneDefaults = {
      room:{ width:9.7, height:11.8, depth:20.5, positionZ:-5.1, portraitOverscan:1.49, imageZoom:1.03, borderOpacity:0.02, wallEmissive:0.35, wallDispAmp:0.02, wallDispSpeed:2.2 },
      lights:{ exposure:2.04, ambient:1.98, hemisphere:1.98, rim:2.55, key:2.21, vaseLight:{ intensity:4.3, distance:17.3, decay:1.6, y:0.08 } },
      vase:{ userScaleMult:1.46, userTallY:2.09, z:-2.1, y:1.3 },
      spin:{ damping:0.975, minSpin:0.10, swipeImpulse:0.0100 },
      post:{ pixelSize:5, ditherStrength:0.17 },
      water:{ amp:1.4, freq:20.0, speed:2.6, falloff:1.1, alpha:0.70, radius:4.5, pixel:5, yOffset:0.0, tint:[0.55, 0.85, 1.0] },
      glass:{ transmission:1.0, thickness:1.6, ior:1.50, roughness:0.06, clearcoat:1.0, ccRough:0.06, envIntensity:2.2 }
    };
    const CONFIG = isPhone() ? structuredClone(phoneDefaults) : structuredClone(desktopDefaults);

    /* -------------------- renderer -------------------- */
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, isPhone() ? 1.5 : 1.8));
    renderer.setSize(vw(), vh(), false);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = CONFIG.lights.exposure;
    renderer.setClearColor(0x000000, 1);
    document.body.appendChild(renderer.domElement);

    /* -------------------- scene / camera -------------------- */
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0d1220, 18, 40);

    const camera = new THREE.PerspectiveCamera(55, vw()/vh(), 0.1, 100);
    camera.position.set(0, 0, 7.5);

    /* -------------------- texture / walls -------------------- */
    const textureURL = "/reilly-album-cvr.jpeg";
    const tLoader = new THREE.TextureLoader();
    tLoader.setCrossOrigin("anonymous");
    const tex = tLoader.load(textureURL, ()=>{
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      applyTextureZoom(tex, CONFIG.room.imageZoom);
    });

    const wallMat = new THREE.MeshStandardMaterial({
      map: tex,
      side: THREE.BackSide,
      roughness: 0.8,
      metalness: 0.0,
      emissive: new THREE.Color(0x2a365c),
      emissiveIntensity: CONFIG.room.wallEmissive,
      envMapIntensity: 0.18
    });

    let wallShaderRef = null;
    wallMat.onBeforeCompile = (shader)=>{
      shader.fragmentShader = shader.fragmentShader.replace(
        '#include <common>',
        `#include <common>
         uniform float uTime;
         uniform float uDispAmp;
         uniform float uDispSpeed;`
      );
      shader.fragmentShader = shader.fragmentShader.replace(
        '#include <map_fragment>',
        `#ifdef USE_MAP
          vec2 uv2 = vMapUv;
          float g = 120.0;
          vec2 grid = floor(uv2 * g)/g;
          float t = uTime * uDispSpeed;
          vec2 warp = vec2(
            sin(grid.y*40.0 + t*2.2),
            cos(grid.x*40.0 - t*1.7)
          ) * uDispAmp;
          vec4 sampledDiffuseColor = texture2D(map, uv2 + warp);
          diffuseColor *= sampledDiffuseColor;
        #endif`
      );
      shader.uniforms.uTime      = { value: 0.0 };
      shader.uniforms.uDispAmp   = { value: CONFIG.room.wallDispAmp };
      shader.uniforms.uDispSpeed = { value: CONFIG.room.wallDispSpeed };
      wallShaderRef = shader;
    };

    function applyTextureZoom(texture, z=1.0){
      const r = 1 / Math.max(z, 0.0001);
      texture.center.set(0.5, 0.5);
      texture.repeat.set(r, r);
      texture.offset.set((1 - r) * 0.5, (1 - r) * 0.5);
      texture.needsUpdate = true;
    }

    /* -------------------- room geometry -------------------- */
    let ROOM_W=CONFIG.room.width, ROOM_H=CONFIG.room.height, ROOM_D=CONFIG.room.depth;
    function buildRoomGeometry(w, h, d){
      const geo = new THREE.BoxGeometry(w, h, d, 1, 1, 1);
      const tileW = 1/4, tileH = 1/3;
      const regions = { px:{u0:0.5,v0:1/3}, nx:{u0:0.0,v0:1/3}, py:{u0:0.25,v0:2/3}, ny:{u0:0.25,v0:0.0}, pz:{u0:0.25,v0:1/3}, nz:{u0:0.75,v0:1/3} };
      const uv = geo.getAttribute('uv'); const arr = uv.array; const stride = 12;
      const faces=[regions.px,regions.nx,regions.py,regions.ny,regions.pz,regions.nz];
      const put=(off,u0,v0,u1,v1,flipH)=>{
        let A=[u0,v0],B=[u1,v0],C=[u1,v1],D=[u0,v1];
        if (flipH){ [A,B,C,D]=[[B[0],B[1]],[A[0],A[1]],[D[0],D[1]],[C[0],C[1]]]; }
        const uvs=[A[0],A[1], B[0],B[1], D[0],D[1],  B[0],B[1], C[0],C[1], D[0],D[1]];
        for(let i=0;i<12;i++) arr[off+i]=uvs[i];
      };
      for(let f=0; f<6; f++){
        const r=faces[f]; const u0=r.u0, v0=r.v0, u1=u0+tileW, v1=v0+tileH;
        put(f*stride,u0,v0,u1,v1,true);
      }
      uv.needsUpdate = true; return geo;
    }

    const roomGeo = buildRoomGeometry(ROOM_W, ROOM_H, ROOM_D);
    const room = new THREE.Mesh(roomGeo, wallMat);
    room.position.set(0, 0, CONFIG.room.positionZ);
    scene.add(room);

    const edges = new THREE.LineSegments(
      new THREE.EdgesGeometry(roomGeo),
      new THREE.LineBasicMaterial({ color: 0xF0F6FF, transparent: true, opacity: CONFIG.room.borderOpacity })
    );
    edges.position.copy(room.position);
    scene.add(edges);

    /* -------------------- lights -------------------- */
    const amb = new THREE.AmbientLight(0xffffff, CONFIG.lights.ambient); scene.add(amb);
    const hemi = new THREE.HemisphereLight(0x9fbfff, 0x202a44, CONFIG.lights.hemisphere); scene.add(hemi);
    const rim = new THREE.DirectionalLight(0xeef3ff, CONFIG.lights.rim); rim.position.set(-1.4, 2.2, 1.6); scene.add(rim);
    const key = new THREE.PointLight(0xffffff, CONFIG.lights.key, 18, 2.0);
    key.position.set(1.5, -ROOM_H*0.1, room.position.z + ROOM_D*0.05);
    scene.add(key);

    /* -------------------- envmap + vase -------------------- */
    const cubeRT = new THREE.WebGLCubeRenderTarget(256, { generateMipmaps:true, minFilter:THREE.LinearMipmapLinearFilter, magFilter:THREE.LinearFilter });
    cubeRT.texture.colorSpace = THREE.SRGBColorSpace;
    const cubeCam = new THREE.CubeCamera(0.1, 100, cubeRT); scene.add(cubeCam);

    const vaseGroup = new THREE.Group(); scene.add(vaseGroup);
    const vaseLight = new THREE.PointLight(0xaad4ff, CONFIG.lights.vaseLight.intensity, CONFIG.lights.vaseLight.distance, CONFIG.lights.vaseLight.decay);
    vaseLight.position.set(0, CONFIG.lights.vaseLight.y, 0);
    vaseGroup.add(vaseLight);

    let vase=null, vaseReady=false, vaseBaseScale=1, userScaleMult=CONFIG.vase.userScaleMult, userTallY=CONFIG.vase.userTallY;
    const glassMaterials = [];

    const VASE_URL = "./spintop.glb";
    const gltf = new GLTFLoader();
    gltf.load(VASE_URL, g=>{
      vase = g.scene;
      const baseGlass = {
        color: 0xffffff,
        metalness: 0.0,
        roughness: 0.05,
        transmission: 1.0,
        thickness: 1.4,
        ior: 1.52,
        clearcoat: 1.0,
        clearcoatRoughness: 0.05,
        attenuationColor: new THREE.Color(0xa8c9ff),
        attenuationDistance: 2.0,
        envMap: cubeRT.texture,
        envMapIntensity: 2.0
      };
      // override with CONFIG.glass
      baseGlass.roughness = CONFIG.glass.roughness;
      baseGlass.transmission = CONFIG.glass.transmission;
      baseGlass.thickness = CONFIG.glass.thickness;
      baseGlass.ior = CONFIG.glass.ior;
      baseGlass.clearcoat = CONFIG.glass.clearcoat;
      baseGlass.clearcoatRoughness = CONFIG.glass.ccRough;
      baseGlass.envMapIntensity = CONFIG.glass.envIntensity;

      vase.traverse(n=>{
        if(n.isMesh){
          const m = new THREE.MeshPhysicalMaterial(baseGlass);
          n.material = m;
          glassMaterials.push(m);
        }
      });
      vaseBaseScale = autoScaleToRoom(vase);
      applyVaseScale();
      vaseGroup.add(vase);
      placeOnFloor(vaseGroup);
      vaseGroup.position.set(0, CONFIG.vase.y, CONFIG.vase.z);
      vaseReady = true;
      syncVasePositionInputs();
    });

    function roomFloorY(){ return -ROOM_H * 0.5 + 0.02; }
    function placeOnFloor(obj){
      obj.updateMatrixWorld(true);
      const bbox = new THREE.Box3().setFromObject(obj);
      const floorY = roomFloorY();
      obj.position.y += (floorY - bbox.min.y);
    }
    function autoScaleToRoom(obj){
      const bbox = new THREE.Box3().setFromObject(obj);
      const size = new THREE.Vector3(); bbox.getSize(size);
      const maxTarget = Math.min(ROOM_H * 0.38, ROOM_W * 0.38);
      return maxTarget / Math.max(size.x, size.y, size.z);
    }
    function applyVaseScale(){
      if(!vase) return;
      const portraitBoost = (isPortrait() && isPhone()) ? 1.7 : 1.0;
      const s = vaseBaseScale * portraitBoost * userScaleMult;
      vase.scale.set(s, s*userTallY, s);
    }

    /* -------------------- spin physics -------------------- */
    let angVel=0, tilt=0, wobblePhase=0;
    let DAMPING=CONFIG.spin.damping, MIN_SPIN=CONFIG.spin.minSpin, IMPULSE_SCALE=CONFIG.spin.swipeImpulse;
    const TILT_FINAL=THREE.MathUtils.degToRad(7);

    let dragging=false, lastX=0, lastT=0;
    function getPointerX(e){ if(e.touches?.length) return e.touches[0].clientX; if(e.changedTouches?.length) return e.changedTouches[0].clientX; return e.clientX??0; }
    function onSwipeDown(e){ dragging=true; lastX=getPointerX(e); lastT=performance.now(); }
    function onSwipeMove(e){ if(!dragging) return; const now=performance.now(); const x=getPointerX(e); const dx=x-lastX; const dt=Math.max(1, now-lastT); angVel += (dx/dt)*IMPULSE_SCALE; lastX=x; lastT=now; }
    function onSwipeUp(){ dragging=false; }
    window.addEventListener('mousedown', onSwipeDown, {passive:true});
    window.addEventListener('mousemove', onSwipeMove, {passive:true});
    window.addEventListener('mouseup',   onSwipeUp,   {passive:true});
    window.addEventListener('touchstart',onSwipeDown, {passive:true});
    window.addEventListener('touchmove', onSwipeMove, {passive:true});
    window.addEventListener('touchend',  onSwipeUp,   {passive:true});

    function updateVase(dt){
      if(!vaseReady) return;
      angVel *= Math.pow(DAMPING, dt*60);
      const floor = (angVel>=0 ? MIN_SPIN : -MIN_SPIN);
      if (Math.abs(angVel) < Math.abs(floor)) angVel = floor;

      vaseGroup.rotation.y += angVel * dt;

      tilt += (TILT_FINAL - tilt) * Math.min(1, dt*2.5);
      const wobbleFreq = Math.max(0.8, Math.abs(angVel)*2.2);
      wobblePhase += wobbleFreq * dt;
      const wobbleAmp = THREE.MathUtils.clamp(0.12 - Math.min(0.1, Math.abs(angVel)*0.08), 0.02, 0.08);
      vaseGroup.rotation.x = tilt + Math.sin(wobblePhase) * wobbleAmp;
      vaseGroup.rotation.z = Math.cos(wobblePhase*0.9) * wobbleAmp * 0.6;
    }

    /* -------------------- pointer/gyro tilt -------------------- */
    const enableMotionBtn = document.getElementById('enableMotion');
    let targetRX=0, targetRY=0; const MAX_TILT=0.085;
    let baseBeta=null, baseGamma=null, pointerMoveAttached=false;

    function onPointerMoveDesktop(e){ const x=(e.clientX/vw())*2-1, y=(e.clientY/vh())*2-1; targetRY=x*MAX_TILT; targetRX=-y*MAX_TILT*0.6; }
    function onDeviceOrientation(e){
      if (baseBeta===null) baseBeta=e.beta||0;
      if (baseGamma===null) baseGamma=e.gamma||0;
      const dB=(e.beta||0)-baseBeta, dG=(e.gamma||0)-baseGamma;
      targetRY = THREE.MathUtils.clamp(dG/45,-1,1)*MAX_TILT;
      targetRX = -THREE.MathUtils.clamp(dB/60,-1,1)*(MAX_TILT*0.6);
    }
    function setupInputMode(){
      if (pointerMoveAttached){ window.removeEventListener('pointermove', onPointerMoveDesktop); pointerMoveAttached=false; }
      window.removeEventListener('deviceorientation', onDeviceOrientation, true);
      enableMotionBtn.style.display = 'none';
      if (isPortrait() && isPhone() && window.DeviceOrientationEvent){
        const needsPerm = typeof DeviceOrientationEvent.requestPermission === 'function';
        if (needsPerm){
          enableMotionBtn.style.display = 'block';
          enableMotionBtn.onclick = async ()=>{
            try { const resp=await DeviceOrientationEvent.requestPermission(); if(resp==='granted'){ window.addEventListener('deviceorientation', onDeviceOrientation, true); enableMotionBtn.remove(); } }
            catch(e){ console.warn(e); }
          };
        } else { window.addEventListener('deviceorientation', onDeviceOrientation, true); }
      } else {
        window.addEventListener('pointermove', onPointerMoveDesktop, {passive:true});
        pointerMoveAttached=true;
      }
    }

    /* -------------------- camera cover -------------------- */
    let PORTRAIT_OVERSCAN = CONFIG.room.portraitOverscan;
    function updateCameraCover(){
      const openingZ = isPortrait()
        ? (room.position.z + ROOM_D*0.5)
        : (room.position.z + ROOM_D*0.0);
      const distance = Math.max(0.0001, camera.position.z - openingZ);
      const aspect = vw()/vh();
      const halfH = ROOM_H*0.5, halfW = ROOM_W*0.5;
      const requiredHalfHeight = Math.max(halfH, halfW / aspect);
      const exactVFOV = 2 * Math.atan(requiredHalfHeight / distance) * 180 / Math.PI;
      camera.fov = exactVFOV * (isPortrait() ? PORTRAIT_OVERSCAN : 1.10);
      camera.aspect = aspect;
      camera.updateProjectionMatrix();
    }

    /* -------------------- post process -------------------- */
    let rt = new THREE.WebGLRenderTarget(vw(), vh(), { minFilter:THREE.LinearFilter, magFilter:THREE.LinearFilter, depthBuffer:true, stencilBuffer:false });
    const screenScene = new THREE.Scene();
    const screenCam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);

    const fsMat = new THREE.ShaderMaterial({
      uniforms:{
        tDiffuse: { value: rt.texture },
        resolution: { value: new THREE.Vector2(vw(), vh()) },
        pixelSize: { value: CONFIG.post.pixelSize },
        ditherStrength: { value: CONFIG.post.ditherStrength }
      },
      vertexShader: `varying vec2 vUv; void main(){ vUv = uv; gl_Position = vec4(position, 1.0); }`,
      fragmentShader: `
        precision highp float;
        uniform sampler2D tDiffuse;
        uniform vec2 resolution;
        uniform float pixelSize;
        uniform float ditherStrength;
        varying vec2 vUv;
        float bayer(vec2 p){
          int x = int(mod(p.x, 4.0));
          int y = int(mod(p.y, 4.0));
          int m[16];
          m[0]=0; m[1]=8; m[2]=2; m[3]=10;
          m[4]=12; m[5]=4; m[6]=14; m[7]=6;
          m[8]=3; m[9]=11; m[10]=1; m[11]=9;
          m[12]=15; m[13]=7; m[14]=13; m[15]=5;
          int idx = y*4 + x;
          return float(m[idx]) / 16.0;
        }
        void main(){
          vec2 px = vec2(max(1.0, pixelSize));
          vec2 uv = floor(vUv * resolution / px) * px / resolution;
          vec3 col = texture2D(tDiffuse, uv).rgb;
          float luma = dot(col, vec3(0.2126,0.7152,0.0722));
          vec2 grid = floor(vUv * resolution / px);
          float thresh = bayer(grid);
          float d = smoothstep(0.0, 1.0, luma + (thresh - 0.5) * ditherStrength);
          col = mix(col*0.9, col*1.1, d);
          gl_FragColor = vec4(col, 1.0);
        }
      `
    });
    const fsQuad = new THREE.Mesh(new THREE.PlaneGeometry(2,2), fsMat);
    screenScene.add(fsQuad);

    function resizePost(){
      rt.setSize(vw(), vh());
      fsMat.uniforms.resolution.value.set(vw(), vh());
    }

    /* -------------------- Water (spin-coupled) -------------------- */
    const waterUniforms = {
      uTime: { value: 0 },
      uCenter: { value: new THREE.Vector3(0, 0, 0) },
      uAmp: { value: CONFIG.water.amp },
      uFreq: { value: CONFIG.water.freq },
      uSpeed: { value: CONFIG.water.speed },
      uFalloff: { value: CONFIG.water.falloff },
      uAlpha: { value: CONFIG.water.alpha },
      uRadius: { value: CONFIG.water.radius },
      uPixel: { value: CONFIG.water.pixel },
      uColor: { value: new THREE.Color().setRGB(...CONFIG.water.tint) },
      uSpinAbs: { value: 0 }
    };

    const waterMat = new THREE.ShaderMaterial({
      transparent:true,
      depthWrite:false,
      depthTest:true,
      blending: THREE.AdditiveBlending,
      uniforms: waterUniforms,
      vertexShader: `
        varying vec3 vWorld;
        varying vec2 vUv;
        void main(){
          vUv = uv;
          vec4 wp = modelMatrix * vec4(position, 1.0);
          vWorld = wp.xyz;
          gl_Position = projectionMatrix * viewMatrix * wp;
        }
      `,
      fragmentShader: `
        precision highp float;
        varying vec3 vWorld;
        varying vec2 vUv;
        uniform vec3  uCenter;
        uniform float uTime, uAmp, uFreq, uSpeed, uFalloff, uAlpha, uRadius, uPixel, uSpinAbs;
        uniform vec3  uColor;
        vec2 pix(vec2 uv){ float p = max(1.0, uPixel); return floor(uv * p) / p; }
        void main(){
          vec2  p  = vWorld.xz - uCenter.xz;
          float d  = length(p);
          float nd = clamp(d / uRadius, 0.0, 1.0);
          float w = sin(d * uFreq - (uTime * (uSpeed * (1.0 + uSpinAbs*2.0))));
          float fall = exp(-nd * uFalloff * 4.0);
          float h = w * uAmp * (0.5 + uSpinAbs*1.4) * fall;
          float ring = smoothstep(0.0, 1.0, abs(w));
          vec3  col  = uColor * (0.6 + 1.6 * h + 0.5 * ring);
          float a    = clamp(uAlpha * (0.35 + 0.9 * h + 0.25 * ring), 0.0, 1.0);
          vec2 uvq = pix(vUv);
          col *= (0.9 + 0.2 * fract(uvq.x * 128.0 + uvq.y * 96.0));
          gl_FragColor = vec4(col, a);
        }
      `
    });

    const waterRadius = Math.max(ROOM_W, ROOM_D) * 0.66;
    const waterGeo = new THREE.CircleGeometry(waterRadius, 128);
    const waterMesh = new THREE.Mesh(waterGeo, waterMat);
    waterMesh.rotation.x = -Math.PI/2;
    waterMesh.position.set(0, -ROOM_H*0.5 + 0.07 + CONFIG.water.yOffset, room.position.z);
    waterMesh.renderOrder = 2;
    scene.add(waterMesh);

    function updateWaterCenterFromVase(){
      if(!vaseReady) return;
      const world = new THREE.Vector3();
      vaseGroup.getWorldPosition(world);
      waterUniforms.uCenter.value.set(world.x, waterMesh.position.y, world.z);
    }

    /* -------------------- resize & layout -------------------- */
    function resizeWater(){
      waterMesh.position.set(0, -ROOM_H*0.5 + 0.07 + CONFIG.water.yOffset, room.position.z);
    }
    function updateLayout(){
      renderer.setSize(vw(), vh(), false);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, isPhone() ? 1.5 : 1.8));
      renderer.toneMappingExposure = CONFIG.lights.exposure;
      key.position.set(1.5, -ROOM_H*0.1, room.position.z + ROOM_D*0.05);
      resizePost();
      updateCameraCover();
      applyVaseScale();
      resizeWater();
    }
    window.addEventListener('resize', updateLayout, {passive:true});
    window.addEventListener('orientationchange', updateLayout, {passive:true});
    if (window.visualViewport) window.visualViewport.addEventListener('resize', updateLayout, {passive:true});
    window.addEventListener('touchmove', e=>e.preventDefault(), {passive:false});
    window.addEventListener('wheel',     e=>e.preventDefault(), {passive:false});

    setupInputMode();
    updateLayout();

    /* -------------------- Spin Popup logic -------------------- */
    const popWrap = document.getElementById('spinPopupWrap');
    const popCard = document.getElementById('spinPopup');
    const popClose = document.getElementById('popClose');
    const btnSpotify = document.getElementById('btnSpotify');
    const btnApple = document.getElementById('btnApple');

    // TODO: replace with your real links
    btnSpotify.href = "https://open.spotify.com/";
    btnApple.href = "https://music.apple.com/";

    let popupVisible = false;
    let lastPopupTime = 0;
    const POPUP_COOLDOWN_MS = 3500;
    const SPIN_POP_THRESHOLD = isPhone() ? 2.2 : 1.8; // tune as desired

    function showPopup(){
      if (popupVisible) return;
      popupVisible = true;
      popWrap.style.display = 'flex';
      // next tick for animation
      requestAnimationFrame(()=> popCard.classList.add('show'));
    }
    function hidePopup(){
      if (!popupVisible) return;
      popupVisible = false;
      popCard.classList.remove('show');
      setTimeout(()=> { popWrap.style.display = 'none'; }, 180);
    }

    popClose.addEventListener('click', hidePopup);
    popWrap.addEventListener('click', (e)=>{ if (e.target === popWrap) hidePopup(); });

    /* -------------------- render loop -------------------- */
    const clock = new THREE.Clock();
    const tmpV3 = new THREE.Vector3();

    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.033);
      const timeSec = clock.elapsedTime;

      // Animate walls with spin-coupled speed/direction
      if (wallShaderRef){
        const dir = (angVel >= 0 ? 1.0 : -1.0);
        const speedFactor = 1.0 + Math.min(3.0, Math.abs(angVel) * 2.4);
        wallShaderRef.uniforms.uTime.value += dt * dir * speedFactor;
      }

      // Popup trigger logic
      if (Math.abs(angVel) > SPIN_POP_THRESHOLD){
        const now = performance.now();
        if (!popupVisible && (now - lastPopupTime) > POPUP_COOLDOWN_MS){
          lastPopupTime = now;
          showPopup();
        }
      }

      // envmap at vase position
      if (vaseReady && vase){
        vase.visible = false;
        cubeCam.position.copy(vaseGroup.getWorldPosition(tmpV3));
        cubeCam.update(renderer, scene);
        vase.visible = true;
      }

      // smooth room tilt
      room.rotation.x += (targetRX - room.rotation.x) * 0.06;
      room.rotation.y += (targetRY - room.rotation.y) * 0.06;
      edges.rotation.copy(room.rotation);

      updateVase(dt);

      // water uniforms
      updateWaterCenterFromVase();
      waterUniforms.uTime.value = timeSec;
      waterUniforms.uSpinAbs.value = Math.abs(angVel);

      // render -> post
      const usePost = (CONFIG.post.pixelSize > 1) || (CONFIG.post.ditherStrength > 0.0001);
      if (usePost){
        renderer.setRenderTarget(rt);
        renderer.render(scene, camera);
        renderer.setRenderTarget(null);
        renderer.render(screenScene, screenCam);
      } else {
        renderer.render(scene, camera);
      }
    }
    animate();

    /* -------------------- Tabs & UI binding (same pattern as before) -------------------- */
    const panel = document.getElementById('panel');
    const gear  = document.getElementById('gear');
    gear.onclick = ()=> { panel.style.display = (panel.style.display !== 'none') ? 'none' : 'block'; };

    document.getElementById('tabs').addEventListener('click', (e)=>{
      const btn = e.target.closest('.tab-btn'); if(!btn) return;
      for (const b of e.currentTarget.querySelectorAll('.tab-btn')) b.classList.toggle('active', b===btn);
      for (const page of document.querySelectorAll('.tabpage')) page.classList.toggle('active', page.id === btn.dataset.tab);
    });

    const $ = id => document.getElementById(id);
    function bindRange(numId, rangeId, getVal, setVal){
      const num=$(numId), range=$(rangeId);
      const init = getVal(); num.value = init; range.value = init;
      const sync=(v)=>{ const val = +v; num.value=val; range.value=val; setVal(val); };
      num.addEventListener('change', e=>sync(e.target.value));
      range.addEventListener('input', e=>sync(e.target.value));
    }

    function rebuildRoom(){
      const newGeo = buildRoomGeometry(ROOM_W, ROOM_H, ROOM_D);
      room.geometry.dispose(); room.geometry=newGeo;
      edges.geometry.dispose(); edges.geometry=new THREE.EdgesGeometry(newGeo);
      updateLayout();
    }

    // Vase bindings
    bindRange('vaseNum','vase', ()=>CONFIG.vase.userScaleMult, v=>{ CONFIG.vase.userScaleMult = Math.max(0.05, v); userScaleMult = CONFIG.vase.userScaleMult; applyVaseScale(); });
    bindRange('vaseYNum','vaseY', ()=>CONFIG.vase.userTallY, v=>{ CONFIG.vase.userTallY = Math.max(0.05, v); userTallY = CONFIG.vase.userTallY; applyVaseScale(); });
    function syncVasePositionInputs(){ $('vaseZ').value = $('vaseZNum').value = vaseGroup.position.z; $('vaseYPos').value = $('vaseYPosNum').value = vaseGroup.position.y; }
    bindRange('vaseZNum','vaseZ', ()=>CONFIG.vase.z, v=>{ CONFIG.vase.z=v; vaseGroup.position.z=v; });
    bindRange('vaseYPosNum','vaseYPos', ()=>CONFIG.vase.y, v=>{ CONFIG.vase.y=v; vaseGroup.position.y=v; });

    // Spin
    bindRange('dampNum','damp', ()=>CONFIG.spin.damping, v=>{ CONFIG.spin.damping=v; DAMPING=v; });
    bindRange('minNum','min', ()=>CONFIG.spin.minSpin, v=>{ CONFIG.spin.minSpin=v; MIN_SPIN=v; });
    bindRange('impNum','imp', ()=>CONFIG.spin.swipeImpulse, v=>{ CONFIG.spin.swipeImpulse=v; IMPULSE_SCALE=v; });

    // Room size & framing
    bindRange('wNum','w', ()=>ROOM_W, v=>{ ROOM_W=v; rebuildRoom(); });
    bindRange('hNum','h', ()=>ROOM_H, v=>{ ROOM_H=v; rebuildRoom(); });
    bindRange('dNum','d', ()=>ROOM_D, v=>{ ROOM_D=v; rebuildRoom(); });
    bindRange('zNum','z', ()=>room.position.z, v=>{ room.position.z=v; edges.position.copy(room.position); updateLayout(); });
    bindRange('ovNum','ov', ()=>PORTRAIT_OVERSCAN, v=>{ PORTRAIT_OVERSCAN=v; updateCameraCover(); });

    $('fitPortrait').onclick = ()=>{
      room.position.z = -ROOM_D * 0.5; edges.position.copy(room.position);
      PORTRAIT_OVERSCAN = Math.max(1.28, PORTRAIT_OVERSCAN);
      $('z').value=$('zNum').value=room.position.z;
      $('ov').value=$('ovNum').value=PORTRAIT_OVERSCAN;
      updateLayout();
    };
    $('fitDesktop').onclick = ()=>{
      room.position.z = -ROOM_D * 0.5; edges.position.copy(room.position);
      PORTRAIT_OVERSCAN = 1.10;
      $('z').value=$('zNum').value=room.position.z;
      $('ov').value=$('ovNum').value=PORTRAIT_OVERSCAN;
      updateLayout();
    };

    // Wall image
    bindRange('zoomNum','zoom', ()=>CONFIG.room.imageZoom, v=>{ CONFIG.room.imageZoom=v; applyTextureZoom(tex, v); });
    bindRange('edgeNum','edge', ()=>edges.material.opacity, v=>{ edges.material.opacity = Math.max(0, Math.min(1, v)); edges.material.needsUpdate=true; });

    // Lights
    bindRange('expNum','exp', ()=>CONFIG.lights.exposure, v=>{ CONFIG.lights.exposure=v; renderer.toneMappingExposure=v; });
    bindRange('ambNum','amb', ()=>CONFIG.lights.ambient, v=>{ CONFIG.lights.ambient=v; amb.intensity=v; });
    bindRange('hemNum','hem', ()=>CONFIG.lights.hemisphere, v=>{ CONFIG.lights.hemisphere=v; hemi.intensity=v; });
    bindRange('rimNum','rim', ()=>CONFIG.lights.rim, v=>{ CONFIG.lights.rim=v; rim.intensity=v; });
    bindRange('keyNum','key', ()=>CONFIG.lights.key, v=>{ CONFIG.lights.key=v; key.intensity=v; });
    bindRange('vlINum','vlI', ()=>CONFIG.lights.vaseLight.intensity, v=>{ CONFIG.lights.vaseLight.intensity=v; vaseLight.intensity=v; });
    bindRange('vlDNum','vlD', ()=>CONFIG.lights.vaseLight.distance,  v=>{ CONFIG.lights.vaseLight.distance=v;  vaseLight.distance=v;  });
    bindRange('vlDecNum','vlDec', ()=>CONFIG.lights.vaseLight.decay, v=>{ CONFIG.lights.vaseLight.decay=v;  vaseLight.decay=v;  });
    bindRange('vlYNum','vlY', ()=>CONFIG.lights.vaseLight.y,        v=>{ CONFIG.lights.vaseLight.y=v;      vaseLight.position.y=v; });

    // Room FX
    bindRange('emisNum','emis', ()=>CONFIG.room.wallEmissive, v=>{ CONFIG.room.wallEmissive=v; wallMat.emissiveIntensity=v; wallMat.needsUpdate=true; });
    bindRange('dispNum','disp', ()=>CONFIG.room.wallDispAmp,  v=>{ CONFIG.room.wallDispAmp=v;  if(wallShaderRef) wallShaderRef.uniforms.uDispAmp.value=v; });
    bindRange('dsNum','ds',     ()=>CONFIG.room.wallDispSpeed,v=>{ CONFIG.room.wallDispSpeed=v;if(wallShaderRef) wallShaderRef.uniforms.uDispSpeed.value=v; });

    // Water
    bindRange('wAmpNum','wAmp', ()=>CONFIG.water.amp,   v=>{ CONFIG.water.amp=v;   waterUniforms.uAmp.value=v; });
    bindRange('wFreqNum','wFreq',()=>CONFIG.water.freq, v=>{ CONFIG.water.freq=v;  waterUniforms.uFreq.value=v; });
    bindRange('wSpeedNum','wSpeed',()=>CONFIG.water.speed, v=>{ CONFIG.water.speed=v; waterUniforms.uSpeed.value=v; });
    bindRange('wFallNum','wFall',()=>CONFIG.water.falloff, v=>{ CONFIG.water.falloff=v; waterUniforms.uFalloff.value=v; });
    bindRange('wAlphaNum','wAlpha',()=>CONFIG.water.alpha, v=>{ CONFIG.water.alpha=v; waterUniforms.uAlpha.value=v; });
    bindRange('wRadNum','wRad',()=>CONFIG.water.radius, v=>{ CONFIG.water.radius=v; waterUniforms.uRadius.value=v; });
    bindRange('wPixNum','wPix',()=>CONFIG.water.pixel, v=>{ CONFIG.water.pixel=v|0; waterUniforms.uPixel.value=v|0; });
    bindRange('wYNum','wY',()=>CONFIG.water.yOffset, v=>{
      CONFIG.water.yOffset=v;
      waterMesh.position.y = -ROOM_H*0.5 + 0.07 + CONFIG.water.yOffset;
    });
    // Tint numbers to uniform
    $('wR').value = CONFIG.water.tint[0];
    $('wG').value = CONFIG.water.tint[1];
    $('wB').value = CONFIG.water.tint[2];
    const setWTint=()=> waterUniforms.uColor.value.setRGB(+$('wR').value, +$('wG').value, +$('wB').value);
    $('wR').addEventListener('change', setWTint);
    $('wG').addEventListener('change', setWTint);
    $('wB').addEventListener('change', setWTint);
    setWTint();

    // Global FX
    bindRange('pixNum','pix', ()=>CONFIG.post.pixelSize, v=>{ CONFIG.post.pixelSize = v|0; fsMat.uniforms.pixelSize.value = Math.max(1, v|0); });
    bindRange('dithNum','dith', ()=>CONFIG.post.ditherStrength, v=>{ CONFIG.post.ditherStrength = Math.max(0, v); fsMat.uniforms.ditherStrength.value = CONFIG.post.ditherStrength; });

    /* Init control values visible */
    function setVal(id, val){ const el=document.getElementById(id); if(el){ el.value=val; } }
    // Vase
    setVal('vase', CONFIG.vase.userScaleMult); setVal('vaseNum', CONFIG.vase.userScaleMult);
    setVal('vaseY', CONFIG.vase.userTallY); setVal('vaseYNum', CONFIG.vase.userTallY);
    setVal('vaseZ', CONFIG.vase.z); setVal('vaseZNum', CONFIG.vase.z);
    setVal('vaseYPos', CONFIG.vase.y); setVal('vaseYPosNum', CONFIG.vase.y);
    // Spin
    setVal('damp', DAMPING); setVal('dampNum', DAMPING);
    setVal('min', MIN_SPIN); setVal('minNum', MIN_SPIN);
    setVal('imp', IMPULSE_SCALE); setVal('impNum', IMPULSE_SCALE);
    // Room
    setVal('w', ROOM_W); setVal('wNum', ROOM_W);
    setVal('h', ROOM_H); setVal('hNum', ROOM_H);
    setVal('d', ROOM_D); setVal('dNum', ROOM_D);
    setVal('z', room.position.z); setVal('zNum', room.position.z);
    setVal('ov', PORTRAIT_OVERSCAN); setVal('ovNum', PORTRAIT_OVERSCAN);
    // Wall image
    setVal('zoom', CONFIG.room.imageZoom); setVal('zoomNum', CONFIG.room.imageZoom);
    setVal('edge', edges.material.opacity); setVal('edgeNum', edges.material.opacity);
    // Lights
    setVal('exp', CONFIG.lights.exposure); setVal('expNum', CONFIG.lights.exposure);
    setVal('amb', CONFIG.lights.ambient); setVal('ambNum', CONFIG.lights.ambient);
    setVal('hem', CONFIG.lights.hemisphere); setVal('hemNum', CONFIG.lights.hemisphere);
    setVal('rim', CONFIG.lights.rim); setVal('rimNum', CONFIG.lights.rim);
    setVal('key', CONFIG.lights.key); setVal('keyNum', CONFIG.lights.key);
    setVal('vlI', CONFIG.lights.vaseLight.intensity); setVal('vlINum', CONFIG.lights.vaseLight.intensity);
    setVal('vlD', CONFIG.lights.vaseLight.distance);  setVal('vlDNum', CONFIG.lights.vaseLight.distance);
    setVal('vlDec', CONFIG.lights.vaseLight.decay);   setVal('vlDecNum', CONFIG.lights.vaseLight.decay);
    setVal('vlY', CONFIG.lights.vaseLight.y);         setVal('vlYNum', CONFIG.lights.vaseLight.y);
    // Room FX
    setVal('emis', CONFIG.room.wallEmissive); setVal('emisNum', CONFIG.room.wallEmissive);
    setVal('disp', CONFIG.room.wallDispAmp);  setVal('dispNum', CONFIG.room.wallDispAmp);
    setVal('ds',   CONFIG.room.wallDispSpeed);setVal('dsNum', CONFIG.room.wallDispSpeed);
    // Water
    setVal('wAmp', CONFIG.water.amp);   setVal('wAmpNum', CONFIG.water.amp);
    setVal('wFreq', CONFIG.water.freq); setVal('wFreqNum', CONFIG.water.freq);
    setVal('wSpeed', CONFIG.water.speed); setVal('wSpeedNum', CONFIG.water.speed);
    setVal('wFall', CONFIG.water.falloff); setVal('wFallNum', CONFIG.water.falloff);
    setVal('wAlpha', CONFIG.water.alpha); setVal('wAlphaNum', CONFIG.water.alpha);
    setVal('wRad', CONFIG.water.radius); setVal('wRadNum', CONFIG.water.radius);
    setVal('wPix', CONFIG.water.pixel); setVal('wPixNum', CONFIG.water.pixel);
    setVal('wY', CONFIG.water.yOffset); setVal('wYNum', CONFIG.water.yOffset);
    // Global FX
    setVal('pix', CONFIG.post.pixelSize); setVal('pixNum', CONFIG.post.pixelSize);
    setVal('dith', CONFIG.post.ditherStrength); setVal('dithNum', CONFIG.post.ditherStrength);

    // Motion permission hint
    (function initMotionButton(){
      if (isPortrait() && isPhone() && window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function'){
        document.getElementById('enableMotion').style.display = 'block';
      }
    })();
  </script>
</body>
</html>
